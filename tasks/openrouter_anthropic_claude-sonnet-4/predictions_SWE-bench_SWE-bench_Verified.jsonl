{"model_name_or_path": "openrouter_anthropic_claude-sonnet-4", "instance_id": "psf__requests-1142", "model_patch": "diff --git a/debug_content_length.py b/debug_content_length.py\nnew file mode 100644\nindex 0000000..f617a0a\n--- /dev/null\n+++ b/debug_content_length.py\n@@ -0,0 +1,32 @@\n+#!/usr/bin/env python\n+\"\"\"Debug the content length logic.\"\"\"\n+\n+import requests\n+from requests.models import PreparedRequest\n+\n+# Monkey patch to add debug prints\n+original_prepare_content_length = PreparedRequest.prepare_content_length\n+\n+def debug_prepare_content_length(self, body):\n+    print(f\"DEBUG: prepare_content_length called with body={repr(body)}, method={self.method}\")\n+    print(f\"DEBUG: body is not None = {body is not None}\")\n+    print(f\"DEBUG: body != '' = {body != ''}\")\n+    print(f\"DEBUG: body != [] = {body != []}\")\n+    print(f\"DEBUG: body != {{}} = {body != {}}\")\n+    \n+    condition = body is not None and body != '' and body != [] and body != {}\n+    print(f\"DEBUG: Overall condition = {condition}\")\n+    \n+    return original_prepare_content_length(self, body)\n+\n+PreparedRequest.prepare_content_length = debug_prepare_content_length\n+\n+def test_case():\n+    print(\"Testing GET request with data=None:\")\n+    req = requests.Request('GET', 'http://httpbin.org/get', data=None)\n+    prepared = req.prepare()\n+    \n+    print(f\"Final headers: {dict(prepared.headers)}\")\n+\n+if __name__ == \"__main__\":\n+    test_case()\n\\ No newline at end of file\ndiff --git a/debug_issue.py b/debug_issue.py\nnew file mode 100644\nindex 0000000..2806d43\n--- /dev/null\n+++ b/debug_issue.py\n@@ -0,0 +1,45 @@\n+#!/usr/bin/env python\n+\"\"\"Debug script to understand the data=None case.\"\"\"\n+\n+import requests\n+from requests.models import PreparedRequest\n+\n+def debug_request_creation():\n+    \"\"\"Debug the request creation process.\"\"\"\n+    print(\"=== Debugging Request Creation ===\")\n+    \n+    # Case 1: No data parameter\n+    print(\"\\n1. GET request with no data parameter:\")\n+    req1 = requests.Request('GET', 'http://httpbin.org/get')\n+    print(f\"  req1.data = {repr(req1.data)}\")\n+    print(f\"  req1.data is None = {req1.data is None}\")\n+    print(f\"  bool(req1.data) = {bool(req1.data)}\")\n+    \n+    # Case 2: Explicit data=None\n+    print(\"\\n2. GET request with data=None:\")\n+    req2 = requests.Request('GET', 'http://httpbin.org/get', data=None)\n+    print(f\"  req2.data = {repr(req2.data)}\")\n+    print(f\"  req2.data is None = {req2.data is None}\")\n+    print(f\"  bool(req2.data) = {bool(req2.data)}\")\n+    \n+    # Case 3: Empty dict\n+    print(\"\\n3. GET request with data={}:\")\n+    req3 = requests.Request('GET', 'http://httpbin.org/get', data={})\n+    print(f\"  req3.data = {repr(req3.data)}\")\n+    print(f\"  req3.data is None = {req3.data is None}\")\n+    print(f\"  bool(req3.data) = {bool(req3.data)}\")\n+    \n+    # Test preparation\n+    print(\"\\n=== Testing Preparation ===\")\n+    for i, req in enumerate([req1, req2, req3], 1):\n+        print(f\"\\nCase {i} preparation:\")\n+        prepared = req.prepare()\n+        print(f\"  prepared.body = {repr(prepared.body)}\")\n+        print(f\"  prepared.body is None = {prepared.body is None}\")\n+        if 'Content-Length' in prepared.headers:\n+            print(f\"  Content-Length = {prepared.headers['Content-Length']}\")\n+        else:\n+            print(\"  No Content-Length header\")\n+\n+if __name__ == \"__main__\":\n+    debug_request_creation()\n\\ No newline at end of file\ndiff --git a/debug_prepare_body.py b/debug_prepare_body.py\nnew file mode 100644\nindex 0000000..c432cb0\n--- /dev/null\n+++ b/debug_prepare_body.py\n@@ -0,0 +1,51 @@\n+#!/usr/bin/env python\n+\"\"\"Debug the prepare_body method.\"\"\"\n+\n+import requests\n+from requests.models import PreparedRequest\n+\n+# Monkey patch to add debug prints\n+original_prepare_body = PreparedRequest.prepare_body\n+\n+def debug_prepare_body(self, data, files):\n+    print(f\"DEBUG: prepare_body called with data={repr(data)}, files={repr(files)}\")\n+    \n+    # Copy the logic from prepare_body to see which path is taken\n+    body = None\n+    content_type = None\n+    length = None\n+    is_stream = False\n+\n+    from requests.compat import basestring\n+    is_stream = all([\n+        hasattr(data, '__iter__'),\n+        not isinstance(data, basestring),\n+        not isinstance(data, dict)\n+    ])\n+    \n+    print(f\"DEBUG: is_stream = {is_stream}\")\n+    print(f\"DEBUG: hasattr(data, '__iter__') = {hasattr(data, '__iter__')}\")\n+    print(f\"DEBUG: isinstance(data, basestring) = {isinstance(data, basestring)}\")\n+    print(f\"DEBUG: isinstance(data, dict) = {isinstance(data, dict)}\")\n+    \n+    from requests.utils import super_len\n+    try:\n+        length = str(super_len(data))\n+        print(f\"DEBUG: length = {length}\")\n+    except (TypeError, AttributeError):\n+        length = False\n+        print(f\"DEBUG: length = False (exception)\")\n+    \n+    return original_prepare_body(self, data, files)\n+\n+PreparedRequest.prepare_body = debug_prepare_body\n+\n+def test_case():\n+    print(\"Testing GET request with data=None:\")\n+    req = requests.Request('GET', 'http://httpbin.org/get', data=None)\n+    prepared = req.prepare()\n+    \n+    print(f\"Final headers: {dict(prepared.headers)}\")\n+\n+if __name__ == \"__main__\":\n+    test_case()\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000..90538f6\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,81 @@\n+#!/usr/bin/env python\n+\"\"\"Script to reproduce the content-length issue with GET requests.\"\"\"\n+\n+import requests\n+from requests.models import PreparedRequest\n+\n+def test_get_request_headers():\n+    \"\"\"Test that GET requests include content-length header.\"\"\"\n+    print(\"Testing GET request headers...\")\n+    \n+    # Create a simple GET request\n+    req = requests.Request('GET', 'http://httpbin.org/get')\n+    prepared = req.prepare()\n+    \n+    print(\"Headers for GET request:\")\n+    for header, value in prepared.headers.items():\n+        print(f\"  {header}: {value}\")\n+    \n+    # Check if Content-Length is present\n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\\nPROBLEM: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return True\n+    else:\n+        print(\"\\nOK: No Content-Length header found\")\n+        return False\n+\n+def test_post_request_headers():\n+    \"\"\"Test that POST requests correctly include content-length header.\"\"\"\n+    print(\"\\nTesting POST request headers...\")\n+    \n+    # Create a POST request with data\n+    req = requests.Request('POST', 'http://httpbin.org/post', data={'key': 'value'})\n+    prepared = req.prepare()\n+    \n+    print(\"Headers for POST request:\")\n+    for header, value in prepared.headers.items():\n+        print(f\"  {header}: {value}\")\n+    \n+    # Check if Content-Length is present\n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\\nOK: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return False\n+    else:\n+        print(\"\\nPROBLEM: No Content-Length header found for POST\")\n+        return True\n+\n+def test_get_request_no_data():\n+    \"\"\"Test GET request with no data explicitly set.\"\"\"\n+    print(\"\\nTesting GET request with no data...\")\n+    \n+    req = requests.Request('GET', 'http://httpbin.org/get', data=None)\n+    prepared = req.prepare()\n+    \n+    print(\"Headers for GET request (data=None):\")\n+    for header, value in prepared.headers.items():\n+        print(f\"  {header}: {value}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\\nPROBLEM: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return True\n+    else:\n+        print(\"\\nOK: No Content-Length header found\")\n+        return False\n+\n+if __name__ == \"__main__\":\n+    has_issue = False\n+    result1 = test_get_request_headers()\n+    result2 = test_post_request_headers()\n+    result3 = test_get_request_no_data()\n+    \n+    print(f\"\\nDEBUG: result1={result1}, result2={result2}, result3={result3}\")\n+    \n+    has_issue = result1 or result2 or result3\n+    print(f\"DEBUG: has_issue={has_issue}\")\n+    \n+    if has_issue:\n+        print(\"\\n=== ISSUE CONFIRMED ===\")\n+        print(\"GET requests are incorrectly including Content-Length header\")\n+    else:\n+        print(\"\\n=== NO ISSUE FOUND ===\")\n+        print(\"Content-Length header behavior is correct\")\n\\ No newline at end of file\ndiff --git a/requests/models.py b/requests/models.py\nindex 9926045..95b91e4 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -359,7 +359,10 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')\n \n             if length:\n-                self.headers['Content-Length'] = length\n+                # Only set Content-Length for streaming if there's actual content\n+                # or if the method typically requires it\n+                if length != '0' or self.method in ('POST', 'PUT', 'PATCH'):\n+                    self.headers['Content-Length'] = length\n             else:\n                 self.headers['Transfer-Encoding'] = 'chunked'\n         # Check if file, fo, generator, iterator.\n@@ -386,13 +389,19 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         self.body = body\n \n     def prepare_content_length(self, body):\n-        self.headers['Content-Length'] = '0'\n-        if hasattr(body, 'seek') and hasattr(body, 'tell'):\n-            body.seek(0, 2)\n-            self.headers['Content-Length'] = str(body.tell())\n-            body.seek(0, 0)\n-        elif body is not None:\n-            self.headers['Content-Length'] = str(len(body))\n+        # Only set Content-Length header if there's actually a body\n+        # or if the method typically requires it\n+        if body is not None and body != '' and body != [] and body != {}:\n+            if hasattr(body, 'seek') and hasattr(body, 'tell'):\n+                body.seek(0, 2)\n+                self.headers['Content-Length'] = str(body.tell())\n+                body.seek(0, 0)\n+            else:\n+                self.headers['Content-Length'] = str(len(body))\n+        elif self.method in ('POST', 'PUT', 'PATCH'):\n+            # For methods that typically send data, set Content-Length to 0 if no body\n+            self.headers['Content-Length'] = '0'\n+        # For GET, HEAD, DELETE, OPTIONS, don't set Content-Length if no body\n \n     def prepare_auth(self, auth):\n         \"\"\"Prepares the given HTTP auth data.\"\"\"\ndiff --git a/test_basic_functionality.py b/test_basic_functionality.py\nnew file mode 100644\nindex 0000000..f230a8c\n--- /dev/null\n+++ b/test_basic_functionality.py\n@@ -0,0 +1,85 @@\n+#!/usr/bin/env python\n+\"\"\"Test basic functionality to ensure my changes don't break anything.\"\"\"\n+\n+import requests\n+from requests.models import Request, PreparedRequest\n+\n+def test_basic_request_preparation():\n+    \"\"\"Test that basic request preparation still works.\"\"\"\n+    print(\"=== Testing Basic Request Preparation ===\")\n+    \n+    # Test GET request\n+    req = Request('GET', 'http://example.com')\n+    prepared = req.prepare()\n+    print(f\"GET request prepared successfully: {prepared}\")\n+    print(f\"GET headers: {dict(prepared.headers)}\")\n+    \n+    # Test POST request\n+    req = Request('POST', 'http://example.com', data={'key': 'value'})\n+    prepared = req.prepare()\n+    print(f\"POST request prepared successfully: {prepared}\")\n+    print(f\"POST headers: {dict(prepared.headers)}\")\n+    \n+    # Test PUT request\n+    req = Request('PUT', 'http://example.com', data={'key': 'value'})\n+    prepared = req.prepare()\n+    print(f\"PUT request prepared successfully: {prepared}\")\n+    print(f\"PUT headers: {dict(prepared.headers)}\")\n+    \n+    print(\"\u2713 All basic request preparations work correctly\")\n+\n+def test_content_length_behavior():\n+    \"\"\"Test the specific Content-Length behavior.\"\"\"\n+    print(\"\\n=== Testing Content-Length Behavior ===\")\n+    \n+    # Methods that should NOT have Content-Length with empty body\n+    no_content_length_methods = ['GET', 'HEAD', 'DELETE', 'OPTIONS']\n+    for method in no_content_length_methods:\n+        req = Request(method, 'http://example.com')\n+        prepared = req.prepare()\n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2717 {method}: Unexpected Content-Length: {prepared.headers['Content-Length']}\")\n+            return False\n+        else:\n+            print(f\"\u2713 {method}: No Content-Length (correct)\")\n+    \n+    # Methods that SHOULD have Content-Length with empty body\n+    content_length_methods = ['POST', 'PUT', 'PATCH']\n+    for method in content_length_methods:\n+        req = Request(method, 'http://example.com')\n+        prepared = req.prepare()\n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2713 {method}: Content-Length = {prepared.headers['Content-Length']} (correct)\")\n+        else:\n+            print(f\"\u2717 {method}: Missing Content-Length\")\n+            return False\n+    \n+    # All methods should have Content-Length when there's actual data\n+    all_methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']\n+    for method in all_methods:\n+        req = Request(method, 'http://example.com', data={'key': 'value'})\n+        prepared = req.prepare()\n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2713 {method} with data: Content-Length = {prepared.headers['Content-Length']} (correct)\")\n+        else:\n+            print(f\"\u2717 {method} with data: Missing Content-Length\")\n+            return False\n+    \n+    return True\n+\n+if __name__ == \"__main__\":\n+    try:\n+        test_basic_request_preparation()\n+        success = test_content_length_behavior()\n+        \n+        if success:\n+            print(\"\\n=== ALL TESTS PASSED ===\")\n+            print(\"Content-Length behavior is working correctly\")\n+        else:\n+            print(\"\\n=== SOME TESTS FAILED ===\")\n+            print(\"There are issues with Content-Length behavior\")\n+    except Exception as e:\n+        print(f\"\\n=== ERROR ===\")\n+        print(f\"Exception occurred: {e}\")\n+        import traceback\n+        traceback.print_exc()\n\\ No newline at end of file\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000..11eece3\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,129 @@\n+#!/usr/bin/env python\n+\"\"\"Comprehensive test of the Content-Length fix.\"\"\"\n+\n+import requests\n+from requests.models import Request\n+from io import StringIO, BytesIO\n+\n+def test_all_scenarios():\n+    \"\"\"Test all possible scenarios for Content-Length behavior.\"\"\"\n+    print(\"=== Comprehensive Content-Length Test ===\")\n+    \n+    test_cases = [\n+        # Format: (method, data, files, expected_has_content_length, description)\n+        \n+        # GET requests - should NOT have Content-Length when no body\n+        ('GET', None, None, False, 'GET with no data'),\n+        ('GET', {}, None, False, 'GET with empty dict'),\n+        ('GET', [], None, False, 'GET with empty list'),\n+        ('GET', '', None, False, 'GET with empty string'),\n+        \n+        # GET requests - SHOULD have Content-Length when there's body data\n+        ('GET', {'key': 'value'}, None, True, 'GET with data dict'),\n+        ('GET', 'string data', None, True, 'GET with string data'),\n+        ('GET', b'bytes data', None, True, 'GET with bytes data'),\n+        \n+        # HEAD requests - should NOT have Content-Length when no body\n+        ('HEAD', None, None, False, 'HEAD with no data'),\n+        ('HEAD', {}, None, False, 'HEAD with empty dict'),\n+        \n+        # HEAD requests - SHOULD have Content-Length when there's body data\n+        ('HEAD', {'key': 'value'}, None, True, 'HEAD with data dict'),\n+        \n+        # DELETE requests - should NOT have Content-Length when no body\n+        ('DELETE', None, None, False, 'DELETE with no data'),\n+        ('DELETE', {}, None, False, 'DELETE with empty dict'),\n+        \n+        # DELETE requests - SHOULD have Content-Length when there's body data\n+        ('DELETE', {'key': 'value'}, None, True, 'DELETE with data dict'),\n+        \n+        # OPTIONS requests - should NOT have Content-Length when no body\n+        ('OPTIONS', None, None, False, 'OPTIONS with no data'),\n+        ('OPTIONS', {}, None, False, 'OPTIONS with empty dict'),\n+        \n+        # OPTIONS requests - SHOULD have Content-Length when there's body data\n+        ('OPTIONS', {'key': 'value'}, None, True, 'OPTIONS with data dict'),\n+        \n+        # POST requests - SHOULD have Content-Length even when no body\n+        ('POST', None, None, True, 'POST with no data'),\n+        ('POST', {}, None, True, 'POST with empty dict'),\n+        ('POST', {'key': 'value'}, None, True, 'POST with data dict'),\n+        \n+        # PUT requests - SHOULD have Content-Length even when no body\n+        ('PUT', None, None, True, 'PUT with no data'),\n+        ('PUT', {}, None, True, 'PUT with empty dict'),\n+        ('PUT', {'key': 'value'}, None, True, 'PUT with data dict'),\n+        \n+        # PATCH requests - SHOULD have Content-Length even when no body\n+        ('PATCH', None, None, True, 'PATCH with no data'),\n+        ('PATCH', {}, None, True, 'PATCH with empty dict'),\n+        ('PATCH', {'key': 'value'}, None, True, 'PATCH with data dict'),\n+    ]\n+    \n+    all_passed = True\n+    \n+    for method, data, files, expected_has_content_length, description in test_cases:\n+        req = Request(method, 'http://example.com', data=data, files=files)\n+        prepared = req.prepare()\n+        \n+        has_content_length = 'Content-Length' in prepared.headers\n+        \n+        if has_content_length == expected_has_content_length:\n+            status = \"\u2713 PASS\"\n+        else:\n+            status = \"\u2717 FAIL\"\n+            all_passed = False\n+        \n+        content_length_info = \"\"\n+        if has_content_length:\n+            content_length_info = f\" (Content-Length: {prepared.headers['Content-Length']})\"\n+        \n+        print(f\"{status}: {description}{content_length_info}\")\n+    \n+    return all_passed\n+\n+def test_file_scenarios():\n+    \"\"\"Test file upload scenarios.\"\"\"\n+    print(\"\\n=== File Upload Scenarios ===\")\n+    \n+    test_cases = [\n+        # All methods with files should have Content-Length\n+        ('GET', None, {'file': ('test.txt', 'test content')}, True, 'GET with text file'),\n+        ('POST', None, {'file': ('test.txt', 'test content')}, True, 'POST with text file'),\n+        ('PUT', None, {'file': ('test.bin', b'test bytes content')}, True, 'PUT with bytes file'),\n+        ('PATCH', None, {'file': ('test.txt', 'test content')}, True, 'PATCH with file'),\n+    ]\n+    \n+    all_passed = True\n+    \n+    for method, data, files, expected_has_content_length, description in test_cases:\n+        req = Request(method, 'http://example.com', data=data, files=files)\n+        prepared = req.prepare()\n+        \n+        has_content_length = 'Content-Length' in prepared.headers\n+        \n+        if has_content_length == expected_has_content_length:\n+            status = \"\u2713 PASS\"\n+        else:\n+            status = \"\u2717 FAIL\"\n+            all_passed = False\n+        \n+        content_length_info = \"\"\n+        if has_content_length:\n+            content_length_info = f\" (Content-Length: {prepared.headers['Content-Length']})\"\n+        \n+        print(f\"{status}: {description}{content_length_info}\")\n+    \n+    return all_passed\n+\n+if __name__ == \"__main__\":\n+    success1 = test_all_scenarios()\n+    success2 = test_file_scenarios()\n+    \n+    print(\"\\n\" + \"=\" * 50)\n+    if success1 and success2:\n+        print(\"\ud83c\udf89 ALL COMPREHENSIVE TESTS PASSED!\")\n+        print(\"\u2713 Content-Length behavior is correct for all scenarios\")\n+    else:\n+        print(\"\u274c SOME COMPREHENSIVE TESTS FAILED!\")\n+        print(\"\u2717 There are still issues with Content-Length behavior\")\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000..76fa420\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,72 @@\n+#!/usr/bin/env python\n+\"\"\"Test edge cases for the Content-Length fix.\"\"\"\n+\n+import requests\n+from requests.models import PreparedRequest\n+\n+def test_various_methods():\n+    \"\"\"Test different HTTP methods.\"\"\"\n+    methods_should_have_content_length = ['POST', 'PUT', 'PATCH']\n+    methods_should_not_have_content_length = ['GET', 'HEAD', 'DELETE', 'OPTIONS']\n+    \n+    print(\"=== Testing methods that should have Content-Length with empty body ===\")\n+    for method in methods_should_have_content_length:\n+        req = requests.Request(method, 'http://httpbin.org/test')\n+        prepared = req.prepare()\n+        \n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2713 {method}: Content-Length = {prepared.headers['Content-Length']}\")\n+        else:\n+            print(f\"\u2717 {method}: No Content-Length header (PROBLEM)\")\n+    \n+    print(\"\\n=== Testing methods that should NOT have Content-Length with empty body ===\")\n+    for method in methods_should_not_have_content_length:\n+        req = requests.Request(method, 'http://httpbin.org/test')\n+        prepared = req.prepare()\n+        \n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2717 {method}: Content-Length = {prepared.headers['Content-Length']} (PROBLEM)\")\n+        else:\n+            print(f\"\u2713 {method}: No Content-Length header\")\n+\n+def test_with_actual_data():\n+    \"\"\"Test that methods with actual data still get Content-Length.\"\"\"\n+    print(\"\\n=== Testing methods with actual data ===\")\n+    \n+    test_data = {'key': 'value'}\n+    methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']\n+    \n+    for method in methods:\n+        req = requests.Request(method, 'http://httpbin.org/test', data=test_data)\n+        prepared = req.prepare()\n+        \n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2713 {method} with data: Content-Length = {prepared.headers['Content-Length']}\")\n+        else:\n+            print(f\"\u2717 {method} with data: No Content-Length header (PROBLEM)\")\n+\n+def test_empty_data_variations():\n+    \"\"\"Test various ways of specifying empty data.\"\"\"\n+    print(\"\\n=== Testing empty data variations for GET ===\")\n+    \n+    variations = [\n+        (\"no data param\", {}),\n+        (\"data=None\", {'data': None}),\n+        (\"data={}\", {'data': {}}),\n+        (\"data=[]\", {'data': []}),\n+        (\"data=''\", {'data': ''}),\n+    ]\n+    \n+    for desc, kwargs in variations:\n+        req = requests.Request('GET', 'http://httpbin.org/test', **kwargs)\n+        prepared = req.prepare()\n+        \n+        if 'Content-Length' in prepared.headers:\n+            print(f\"\u2717 GET {desc}: Content-Length = {prepared.headers['Content-Length']} (PROBLEM)\")\n+        else:\n+            print(f\"\u2713 GET {desc}: No Content-Length header\")\n+\n+if __name__ == \"__main__\":\n+    test_various_methods()\n+    test_with_actual_data()\n+    test_empty_data_variations()\n\\ No newline at end of file\ndiff --git a/test_file_uploads.py b/test_file_uploads.py\nnew file mode 100644\nindex 0000000..5c71d83\n--- /dev/null\n+++ b/test_file_uploads.py\n@@ -0,0 +1,87 @@\n+#!/usr/bin/env python\n+\"\"\"Test file uploads to ensure Content-Length is handled correctly.\"\"\"\n+\n+import requests\n+from requests.models import Request\n+from io import StringIO\n+\n+def test_file_uploads():\n+    \"\"\"Test that file uploads still work correctly.\"\"\"\n+    print(\"=== Testing File Uploads ===\")\n+    \n+    # Create a simple file-like object\n+    file_content = \"This is test file content\"\n+    file_obj = StringIO(file_content)\n+    \n+    # Test POST with files\n+    req = Request('POST', 'http://example.com', files={'file': file_obj})\n+    prepared = req.prepare()\n+    \n+    print(f\"POST with files headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2713 POST with files: Content-Length = {prepared.headers['Content-Length']}\")\n+    else:\n+        print(\"\u2717 POST with files: Missing Content-Length\")\n+        return False\n+    \n+    # Test GET with files (unusual but should still work)\n+    file_obj.seek(0)  # Reset file position\n+    req = Request('GET', 'http://example.com', files={'file': file_obj})\n+    prepared = req.prepare()\n+    \n+    print(f\"GET with files headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2713 GET with files: Content-Length = {prepared.headers['Content-Length']}\")\n+    else:\n+        print(\"\u2717 GET with files: Missing Content-Length\")\n+        return False\n+    \n+    return True\n+\n+def test_streaming_data():\n+    \"\"\"Test streaming data.\"\"\"\n+    print(\"\\n=== Testing Streaming Data ===\")\n+    \n+    # Test with a generator (streaming data)\n+    def data_generator():\n+        yield b\"chunk1\"\n+        yield b\"chunk2\"\n+        yield b\"chunk3\"\n+    \n+    # Test POST with streaming data\n+    req = Request('POST', 'http://example.com', data=data_generator())\n+    prepared = req.prepare()\n+    \n+    print(f\"POST with streaming data headers: {dict(prepared.headers)}\")\n+    \n+    # Streaming data should either have Content-Length or Transfer-Encoding\n+    has_content_length = 'Content-Length' in prepared.headers\n+    has_transfer_encoding = 'Transfer-Encoding' in prepared.headers\n+    \n+    if has_content_length or has_transfer_encoding:\n+        if has_content_length:\n+            print(f\"\u2713 POST with streaming: Content-Length = {prepared.headers['Content-Length']}\")\n+        if has_transfer_encoding:\n+            print(f\"\u2713 POST with streaming: Transfer-Encoding = {prepared.headers['Transfer-Encoding']}\")\n+    else:\n+        print(\"\u2717 POST with streaming: Missing both Content-Length and Transfer-Encoding\")\n+        return False\n+    \n+    return True\n+\n+if __name__ == \"__main__\":\n+    try:\n+        success1 = test_file_uploads()\n+        success2 = test_streaming_data()\n+        \n+        if success1 and success2:\n+            print(\"\\n=== ALL FILE UPLOAD TESTS PASSED ===\")\n+        else:\n+            print(\"\\n=== SOME FILE UPLOAD TESTS FAILED ===\")\n+    except Exception as e:\n+        print(f\"\\n=== ERROR ===\")\n+        print(f\"Exception occurred: {e}\")\n+        import traceback\n+        traceback.print_exc()\n\\ No newline at end of file\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000..ccaf959\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,117 @@\n+#!/usr/bin/env python\n+\"\"\"Test that the original issue described in the PR is fixed.\"\"\"\n+\n+import requests\n+\n+def test_original_issue():\n+    \"\"\"\n+    Test the original issue: requests.get should not always send content-length header.\n+    \n+    The PR description states:\n+    \"It seems like that request.get always adds 'content-length' header to the request.\n+    I think that the right behavior is not to add this header automatically in GET requests\n+    or add the possibility to not send it.\"\n+    \"\"\"\n+    print(\"=== Testing Original Issue ===\")\n+    print(\"Issue: requests.get is ALWAYS sending content length\")\n+    print()\n+    \n+    # Test 1: Basic GET request should not have Content-Length\n+    print(\"Test 1: Basic GET request\")\n+    req = requests.Request('GET', 'http://amazon.com')\n+    prepared = req.prepare()\n+    \n+    print(f\"Headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2717 FAIL: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        print(\"  This would cause amazon.com to return 503\")\n+        return False\n+    else:\n+        print(\"\u2713 PASS: No Content-Length header found\")\n+        print(\"  This should work fine with amazon.com\")\n+    \n+    print()\n+    \n+    # Test 2: GET request with explicit data=None should not have Content-Length\n+    print(\"Test 2: GET request with data=None\")\n+    req = requests.Request('GET', 'http://amazon.com', data=None)\n+    prepared = req.prepare()\n+    \n+    print(f\"Headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2717 FAIL: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return False\n+    else:\n+        print(\"\u2713 PASS: No Content-Length header found\")\n+    \n+    print()\n+    \n+    # Test 3: GET request with empty dict should not have Content-Length\n+    print(\"Test 3: GET request with data={}\")\n+    req = requests.Request('GET', 'http://amazon.com', data={})\n+    prepared = req.prepare()\n+    \n+    print(f\"Headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2717 FAIL: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return False\n+    else:\n+        print(\"\u2713 PASS: No Content-Length header found\")\n+    \n+    print()\n+    \n+    # Test 4: Verify that POST requests still work correctly\n+    print(\"Test 4: POST request should still have Content-Length\")\n+    req = requests.Request('POST', 'http://httpbin.org/post', data={'key': 'value'})\n+    prepared = req.prepare()\n+    \n+    print(f\"Headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2713 PASS: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+    else:\n+        print(\"\u2717 FAIL: Content-Length header is missing for POST\")\n+        return False\n+    \n+    return True\n+\n+def test_using_requests_api():\n+    \"\"\"Test using the actual requests.get API function.\"\"\"\n+    print(\"\\n=== Testing with requests.get() API ===\")\n+    \n+    # We can't actually make the request, but we can prepare it through the session\n+    session = requests.Session()\n+    \n+    # Prepare a GET request\n+    req = requests.Request('GET', 'http://amazon.com')\n+    prepared = req.prepare()\n+    \n+    print(f\"requests.get() equivalent headers: {dict(prepared.headers)}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\u2717 FAIL: requests.get() would send Content-Length: {prepared.headers['Content-Length']}\")\n+        return False\n+    else:\n+        print(\"\u2713 PASS: requests.get() would not send Content-Length header\")\n+        return True\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing fix for: requests.get is ALWAYS sending content length\")\n+    print(\"=\" * 60)\n+    \n+    success1 = test_original_issue()\n+    success2 = test_using_requests_api()\n+    \n+    print(\"\\n\" + \"=\" * 60)\n+    if success1 and success2:\n+        print(\"\ud83c\udf89 SUCCESS: Original issue has been FIXED!\")\n+        print(\"\u2713 GET requests no longer automatically include Content-Length header\")\n+        print(\"\u2713 This should resolve the amazon.com 503 error issue\")\n+        print(\"\u2713 POST requests still work correctly\")\n+    else:\n+        print(\"\u274c FAILURE: Original issue is NOT fixed\")\n+        print(\"\u2717 GET requests still include Content-Length header\")\n+        print(\"\u2717 This would still cause issues with servers like amazon.com\")\n\\ No newline at end of file\ndiff --git a/test_requests_get.py b/test_requests_get.py\nnew file mode 100644\nindex 0000000..a157cc0\n--- /dev/null\n+++ b/test_requests_get.py\n@@ -0,0 +1,52 @@\n+#!/usr/bin/env python\n+\"\"\"Test the actual requests.get function.\"\"\"\n+\n+import requests\n+\n+def test_requests_get():\n+    \"\"\"Test that requests.get doesn't send Content-Length.\"\"\"\n+    print(\"=== Testing requests.get() ===\")\n+    \n+    # We can't actually make the request, but we can prepare it\n+    req = requests.Request('GET', 'http://httpbin.org/get')\n+    prepared = req.prepare()\n+    \n+    print(\"Headers for requests.get():\")\n+    for header, value in prepared.headers.items():\n+        print(f\"  {header}: {value}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\\n\u2717 PROBLEM: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return False\n+    else:\n+        print(\"\\n\u2713 OK: No Content-Length header found\")\n+        return True\n+\n+def test_requests_post():\n+    \"\"\"Test that requests.post still sends Content-Length.\"\"\"\n+    print(\"\\n=== Testing requests.post() ===\")\n+    \n+    req = requests.Request('POST', 'http://httpbin.org/post', data={'key': 'value'})\n+    prepared = req.prepare()\n+    \n+    print(\"Headers for requests.post():\")\n+    for header, value in prepared.headers.items():\n+        print(f\"  {header}: {value}\")\n+    \n+    if 'Content-Length' in prepared.headers:\n+        print(f\"\\n\u2713 OK: Content-Length header is present: {prepared.headers['Content-Length']}\")\n+        return True\n+    else:\n+        print(\"\\n\u2717 PROBLEM: No Content-Length header found\")\n+        return False\n+\n+if __name__ == \"__main__\":\n+    get_ok = test_requests_get()\n+    post_ok = test_requests_post()\n+    \n+    if get_ok and post_ok:\n+        print(\"\\n=== ALL TESTS PASSED ===\")\n+        print(\"requests.get() and requests.post() behave correctly\")\n+    else:\n+        print(\"\\n=== SOME TESTS FAILED ===\")\n+        print(\"There are still issues with the implementation\")\n\\ No newline at end of file\n"}
{"model_name_or_path": "openrouter_anthropic_claude-sonnet-4", "instance_id": "psf__requests-1724", "model_patch": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000..240dcf6\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,49 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Script to reproduce the Unicode method names issue\n+\"\"\"\n+\n+import requests\n+import tempfile\n+import os\n+\n+def test_unicode_method_issue():\n+    # Create a temporary file with some binary content to simulate the issue\n+    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n+        # Write some binary content that includes non-ASCII bytes\n+        tmp_file.write(b'\\xcf\\x80\\x00\\x01\\x02\\x03')  # Some binary data with non-ASCII bytes\n+        tmp_file_path = tmp_file.name\n+    \n+    try:\n+        # This should work fine (method as regular string)\n+        print(\"Testing with regular string method...\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            response = requests.request(method='POST', url='http://httpbin.org/post', files=files)\n+            print(\"SUCCESS: Regular string method works\")\n+        except Exception as e:\n+            print(\"ERROR with regular string method:\", str(e))\n+        finally:\n+            files['file'].close()\n+        \n+        # This should fail with UnicodeDecodeError (method as unicode string)\n+        print(\"\\nTesting with unicode string method...\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            response = requests.request(method=u'POST', url='http://httpbin.org/post', files=files)\n+            print(\"SUCCESS: Unicode string method works\")\n+        except UnicodeDecodeError as e:\n+            print(\"ERROR: UnicodeDecodeError occurred:\", str(e))\n+        except Exception as e:\n+            print(\"ERROR with unicode string method:\", str(e))\n+        finally:\n+            files['file'].close()\n+            \n+    finally:\n+        # Clean up\n+        os.unlink(tmp_file_path)\n+\n+if __name__ == '__main__':\n+    test_unicode_method_issue()\n\\ No newline at end of file\ndiff --git a/requests/models.py b/requests/models.py\nindex f82f56a..2d49061 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -307,7 +307,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         \"\"\"Prepares the given HTTP method.\"\"\"\n         self.method = method\n         if self.method is not None:\n-            self.method = self.method.upper()\n+            self.method = to_native_string(self.method.upper())\n \n     def prepare_url(self, url, params):\n         \"\"\"Prepares the given HTTP URL.\"\"\"\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex cc72f65..f353324 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -22,7 +22,7 @@ from .structures import CaseInsensitiveDict\n \n from .adapters import HTTPAdapter\n \n-from .utils import requote_uri, get_environ_proxies, get_netrc_auth\n+from .utils import requote_uri, get_environ_proxies, get_netrc_auth, to_native_string\n \n from .status_codes import codes\n REDIRECT_STATI = (\n@@ -311,7 +311,7 @@ class Session(SessionRedirectMixin):\n         \"\"\"\n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+            method = to_native_string(method.upper()),\n             url = url,\n             headers = headers,\n             files = files,\ndiff --git a/test_comprehensive_fix.py b/test_comprehensive_fix.py\nnew file mode 100644\nindex 0000000..d79d648\n--- /dev/null\n+++ b/test_comprehensive_fix.py\n@@ -0,0 +1,146 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Comprehensive test to verify the Unicode method names fix\n+\"\"\"\n+\n+import requests\n+from requests.utils import to_native_string\n+from requests.compat import builtin_str, is_py2\n+\n+def test_to_native_string_comprehensive():\n+    \"\"\"Test to_native_string function comprehensively\"\"\"\n+    print(\"Testing to_native_string function comprehensively...\")\n+    \n+    # Test with various inputs\n+    test_cases = [\n+        ('GET', 'GET'),\n+        ('post', 'post'),\n+        ('PUT', 'PUT'),\n+        ('delete', 'delete'),\n+    ]\n+    \n+    for input_str, expected in test_cases:\n+        result = to_native_string(input_str)\n+        assert result == expected\n+        assert isinstance(result, builtin_str)\n+        print(f\"   \u2713 '{input_str}' -> '{result}' (type: {type(result)})\")\n+    \n+    # Note: to_native_string doesn't handle None, but prepare_method does\n+    print(f\"   \u2713 to_native_string works for all string inputs\")\n+\n+def test_method_preparation():\n+    \"\"\"Test method preparation in PreparedRequest\"\"\"\n+    print(\"\\nTesting method preparation in PreparedRequest...\")\n+    \n+    from requests.models import PreparedRequest\n+    \n+    # Test various method inputs\n+    test_methods = ['GET', 'post', 'Put', 'DELETE', None]\n+    \n+    for method in test_methods:\n+        prep = PreparedRequest()\n+        prep.prepare_method(method)\n+        \n+        if method is None:\n+            assert prep.method is None\n+            print(f\"   \u2713 None method -> None\")\n+        else:\n+            assert prep.method == method.upper()\n+            assert isinstance(prep.method, builtin_str)\n+            print(f\"   \u2713 '{method}' -> '{prep.method}' (type: {type(prep.method)})\")\n+\n+def test_request_creation():\n+    \"\"\"Test Request creation with various method types\"\"\"\n+    print(\"\\nTesting Request creation with various method types...\")\n+    \n+    test_methods = ['GET', 'post', 'Put', 'DELETE']\n+    \n+    for method in test_methods:\n+        # Test regular Request creation\n+        req = requests.Request(method=method, url='http://example.com')\n+        prepared = req.prepare()\n+        \n+        assert prepared.method == method.upper()\n+        assert isinstance(prepared.method, builtin_str)\n+        print(f\"   \u2713 Request with method '{method}' -> '{prepared.method}' (type: {type(prepared.method)})\")\n+\n+def test_session_request():\n+    \"\"\"Test Session.request with various method types\"\"\"\n+    print(\"\\nTesting Session.request with various method types...\")\n+    \n+    session = requests.Session()\n+    test_methods = ['GET', 'post', 'Put', 'DELETE']\n+    \n+    for method in test_methods:\n+        # Create request via session\n+        req = requests.Request(method=method, url='http://example.com')\n+        prepared = session.prepare_request(req)\n+        \n+        assert prepared.method == method.upper()\n+        assert isinstance(prepared.method, builtin_str)\n+        print(f\"   \u2713 Session request with method '{method}' -> '{prepared.method}' (type: {type(prepared.method)})\")\n+\n+def test_unicode_safety():\n+    \"\"\"Test that unicode strings are properly handled\"\"\"\n+    print(\"\\nTesting unicode string safety...\")\n+    \n+    # In Python 3, all strings are unicode, but we can still test the conversion\n+    unicode_methods = ['GET', 'POST', 'PUT', 'DELETE']\n+    \n+    for method in unicode_methods:\n+        # Test with Request\n+        req = requests.Request(method=method, url='http://example.com')\n+        prepared = req.prepare()\n+        \n+        assert prepared.method == method.upper()\n+        assert isinstance(prepared.method, builtin_str)\n+        \n+        # Test with PreparedRequest directly\n+        prep = requests.models.PreparedRequest()\n+        prep.prepare_method(method)\n+        \n+        assert prep.method == method.upper()\n+        assert isinstance(prep.method, builtin_str)\n+        \n+        print(f\"   \u2713 Unicode method '{method}' handled safely\")\n+\n+def test_edge_cases():\n+    \"\"\"Test edge cases\"\"\"\n+    print(\"\\nTesting edge cases...\")\n+    \n+    # Test with None\n+    req = requests.Request(method=None, url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method is None\n+    print(\"   \u2713 None method handled correctly\")\n+    \n+    # Test with empty string\n+    req = requests.Request(method='', url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method == ''\n+    assert isinstance(prepared.method, builtin_str)\n+    print(\"   \u2713 Empty string method handled correctly\")\n+    \n+    # Test case sensitivity\n+    req = requests.Request(method='pOsT', url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method == 'POST'\n+    assert isinstance(prepared.method, builtin_str)\n+    print(\"   \u2713 Case sensitivity handled correctly\")\n+\n+if __name__ == '__main__':\n+    print(f\"Running comprehensive tests on Python {'.'.join(map(str, __import__('sys').version_info[:3]))}\")\n+    print(f\"is_py2: {is_py2}\")\n+    print(f\"builtin_str: {builtin_str}\")\n+    print()\n+    \n+    test_to_native_string_comprehensive()\n+    test_method_preparation()\n+    test_request_creation()\n+    test_session_request()\n+    test_unicode_safety()\n+    test_edge_cases()\n+    \n+    print(\"\\n\ud83c\udf89 All comprehensive tests passed! The fix is robust and handles all cases correctly.\")\n\\ No newline at end of file\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000..b82fdc0\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,103 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Test script to verify the Unicode method names fix\n+\"\"\"\n+\n+import sys\n+import requests\n+from requests.utils import to_native_string\n+from requests.compat import builtin_str, is_py2\n+\n+def test_to_native_string():\n+    \"\"\"Test the to_native_string function behavior\"\"\"\n+    print(\"Testing to_native_string function:\")\n+    \n+    # Test with regular string\n+    regular_str = 'POST'\n+    result1 = to_native_string(regular_str.upper())\n+    print(f\"Regular string 'POST' -> {repr(result1)} (type: {type(result1)})\")\n+    \n+    # Test with unicode string (in Python 2 this would be unicode, in Python 3 it's str)\n+    if sys.version_info[0] == 2:\n+        unicode_str = unicode('POST')  # This would be u'POST' in Python 2\n+    else:\n+        unicode_str = 'POST'  # In Python 3, strings are unicode by default\n+    \n+    result2 = to_native_string(unicode_str.upper())\n+    print(f\"Unicode string 'POST' -> {repr(result2)} (type: {type(result2)})\")\n+    \n+    # Verify that the result is always a builtin_str (native string type)\n+    assert isinstance(result1, builtin_str), f\"Expected builtin_str, got {type(result1)}\"\n+    assert isinstance(result2, builtin_str), f\"Expected builtin_str, got {type(result2)}\"\n+    \n+    print(\"\u2713 to_native_string works correctly\")\n+\n+def test_method_handling():\n+    \"\"\"Test that method handling works correctly\"\"\"\n+    print(\"\\nTesting method handling in Request creation:\")\n+    \n+    # Test with regular string method\n+    req1 = requests.Request(method='POST', url='http://example.com')\n+    prepared1 = req1.prepare()\n+    print(f\"Regular method 'POST' -> {repr(prepared1.method)} (type: {type(prepared1.method)})\")\n+    \n+    # Test with unicode string method\n+    if sys.version_info[0] == 2:\n+        unicode_method = unicode('POST')\n+    else:\n+        unicode_method = 'POST'\n+    \n+    req2 = requests.Request(method=unicode_method, url='http://example.com')\n+    prepared2 = req2.prepare()\n+    print(f\"Unicode method 'POST' -> {repr(prepared2.method)} (type: {type(prepared2.method)})\")\n+    \n+    # Verify that both result in native strings\n+    assert isinstance(prepared1.method, builtin_str), f\"Expected builtin_str, got {type(prepared1.method)}\"\n+    assert isinstance(prepared2.method, builtin_str), f\"Expected builtin_str, got {type(prepared2.method)}\"\n+    \n+    # Verify that both have the same value\n+    assert prepared1.method == prepared2.method, f\"Methods should be equal: {prepared1.method} != {prepared2.method}\"\n+    \n+    print(\"\u2713 Method handling works correctly\")\n+\n+def test_session_request():\n+    \"\"\"Test that session.request works correctly with unicode methods\"\"\"\n+    print(\"\\nTesting session.request with unicode methods:\")\n+    \n+    session = requests.Session()\n+    \n+    # Test with regular string method\n+    try:\n+        req1 = session.prepare_request(requests.Request(method='GET', url='http://example.com'))\n+        print(f\"Regular method prepared: {repr(req1.method)} (type: {type(req1.method)})\")\n+        assert isinstance(req1.method, builtin_str)\n+    except Exception as e:\n+        print(f\"Error with regular method: {e}\")\n+        \n+    # Test with unicode string method\n+    try:\n+        if sys.version_info[0] == 2:\n+            unicode_method = unicode('GET')\n+        else:\n+            unicode_method = 'GET'\n+            \n+        req2 = session.prepare_request(requests.Request(method=unicode_method, url='http://example.com'))\n+        print(f\"Unicode method prepared: {repr(req2.method)} (type: {type(req2.method)})\")\n+        assert isinstance(req2.method, builtin_str)\n+    except Exception as e:\n+        print(f\"Error with unicode method: {e}\")\n+        \n+    print(\"\u2713 Session request handling works correctly\")\n+\n+if __name__ == '__main__':\n+    print(f\"Running tests on Python {sys.version}\")\n+    print(f\"is_py2: {is_py2}\")\n+    print(f\"builtin_str: {builtin_str}\")\n+    \n+    test_to_native_string()\n+    test_method_handling()\n+    test_session_request()\n+    \n+    print(\"\\n\u2713 All tests passed!\")\n\\ No newline at end of file\ndiff --git a/test_requests_api.py b/test_requests_api.py\nnew file mode 100644\nindex 0000000..ead897b\n--- /dev/null\n+++ b/test_requests_api.py\n@@ -0,0 +1,68 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Test the requests.request() API with unicode method names\n+\"\"\"\n+\n+import requests\n+import tempfile\n+import os\n+from requests.compat import builtin_str\n+\n+def test_requests_api():\n+    \"\"\"Test the requests.request() API with unicode method names\"\"\"\n+    \n+    print(\"Testing requests.request() API...\")\n+    \n+    # Create a temporary file\n+    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n+        tmp_file.write(b'test content')\n+        tmp_file_path = tmp_file.name\n+    \n+    try:\n+        # Test 1: Regular string method\n+        print(\"\\n1. Testing requests.request() with regular string method\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This should work\n+            req = requests.Request(method='POST', url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str)\n+            print(\"   \u2713 Regular string method works\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 2: Unicode string method (the problematic case from the PR)\n+        print(\"\\n2. Testing requests.request() with unicode string method\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This was the problematic case: method=u'POST'\n+            unicode_method = 'POST'  # In Python 2, this would be u'POST'\n+            req = requests.Request(method=unicode_method, url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str)\n+            print(\"   \u2713 Unicode string method works (fixed!)\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 3: Test different HTTP methods\n+        print(\"\\n3. Testing different HTTP methods\")\n+        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']\n+        for method in methods:\n+            req = requests.Request(method=method, url='http://example.com')\n+            prepared = req.prepare()\n+            assert isinstance(prepared.method, builtin_str)\n+            assert prepared.method == method.upper()\n+        print(\"   \u2713 All HTTP methods work correctly\")\n+        \n+        print(\"\\n\u2705 requests.request() API works correctly with unicode methods!\")\n+        \n+    finally:\n+        # Clean up\n+        os.unlink(tmp_file_path)\n+\n+if __name__ == '__main__':\n+    test_requests_api()\n\\ No newline at end of file\ndiff --git a/test_unicode_method_fix.py b/test_unicode_method_fix.py\nnew file mode 100644\nindex 0000000..c3b43d9\n--- /dev/null\n+++ b/test_unicode_method_fix.py\n@@ -0,0 +1,124 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Test script to verify the Unicode method names fix works correctly.\n+This simulates the issue described in the PR.\n+\"\"\"\n+\n+import requests\n+import tempfile\n+import os\n+from requests.utils import to_native_string\n+from requests.compat import builtin_str\n+\n+def test_unicode_method_fix():\n+    \"\"\"Test that unicode method names are properly converted to native strings\"\"\"\n+    \n+    print(\"Testing Unicode method name fix...\")\n+    \n+    # Create a temporary file with some content\n+    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n+        tmp_file.write(b'test content')\n+        tmp_file_path = tmp_file.name\n+    \n+    try:\n+        # Test 1: Regular string method (should work)\n+        print(\"\\n1. Testing with regular string method 'POST':\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # Create request with regular string method\n+            req = requests.Request(method='POST', url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str), \"Method should be native string\"\n+            assert prepared.method == 'POST', \"Method should be 'POST'\"\n+            print(\"   \u2713 Regular string method works correctly\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 2: Unicode string method (this was the problematic case)\n+        print(\"\\n2. Testing with unicode string method u'POST':\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # In Python 3, all strings are unicode, but we can still test the conversion\n+            unicode_method = 'POST'  # This would be u'POST' in Python 2\n+            req = requests.Request(method=unicode_method, url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str), \"Method should be native string\"\n+            assert prepared.method == 'POST', \"Method should be 'POST'\"\n+            print(\"   \u2713 Unicode string method works correctly\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 3: Test via session.request (the original failing case)\n+        print(\"\\n3. Testing via session.request with unicode method:\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This simulates the exact call from the PR description\n+            session = requests.Session()\n+            unicode_method = 'POST'  # This would be u'POST' in Python 2\n+            \n+            # Prepare the request (this is where the fix is applied)\n+            req = requests.Request(method=unicode_method, url='http://httpbin.org/post', files=files)\n+            prepared = session.prepare_request(req)\n+            \n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str), \"Method should be native string\"\n+            assert prepared.method == 'POST', \"Method should be 'POST'\"\n+            print(\"   \u2713 Session request with unicode method works correctly\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 4: Test to_native_string function directly\n+        print(\"\\n4. Testing to_native_string function directly:\")\n+        \n+        # Test with different method names\n+        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']\n+        for method in methods:\n+            # Test regular string\n+            result1 = to_native_string(method.upper())\n+            assert isinstance(result1, builtin_str), f\"Result should be native string for {method}\"\n+            \n+            # Test \"unicode\" string (in Python 3, this is the same as regular string)\n+            result2 = to_native_string(method.upper())\n+            assert isinstance(result2, builtin_str), f\"Result should be native string for unicode {method}\"\n+            assert result1 == result2, f\"Results should be equal for {method}\"\n+        \n+        print(\"   \u2713 to_native_string function works correctly for all HTTP methods\")\n+        \n+        print(\"\\n\u2705 All tests passed! The Unicode method name fix is working correctly.\")\n+        \n+    finally:\n+        # Clean up\n+        os.unlink(tmp_file_path)\n+\n+def test_edge_cases():\n+    \"\"\"Test edge cases for the fix\"\"\"\n+    print(\"\\n5. Testing edge cases:\")\n+    \n+    # Test with None method\n+    req = requests.Request(method=None, url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method is None, \"None method should remain None\"\n+    print(\"   \u2713 None method handled correctly\")\n+    \n+    # Test with lowercase method\n+    req = requests.Request(method='post', url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method == 'POST', \"Lowercase method should be converted to uppercase\"\n+    assert isinstance(prepared.method, builtin_str), \"Method should be native string\"\n+    print(\"   \u2713 Lowercase method handled correctly\")\n+    \n+    # Test with mixed case method\n+    req = requests.Request(method='PoSt', url='http://example.com')\n+    prepared = req.prepare()\n+    assert prepared.method == 'POST', \"Mixed case method should be converted to uppercase\"\n+    assert isinstance(prepared.method, builtin_str), \"Method should be native string\"\n+    print(\"   \u2713 Mixed case method handled correctly\")\n+\n+if __name__ == '__main__':\n+    test_unicode_method_fix()\n+    test_edge_cases()\n+    print(\"\\n\ud83c\udf89 All tests completed successfully!\")\n\\ No newline at end of file\ndiff --git a/test_unicode_method_pr.py b/test_unicode_method_pr.py\nnew file mode 100644\nindex 0000000..49f95f2\n--- /dev/null\n+++ b/test_unicode_method_pr.py\n@@ -0,0 +1,107 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Test to verify the specific issue from the PR is fixed.\n+This test simulates the exact scenario described in the PR.\n+\"\"\"\n+\n+import requests\n+import tempfile\n+import os\n+from requests.compat import builtin_str\n+\n+def test_pr_scenario():\n+    \"\"\"Test the exact scenario from the PR description\"\"\"\n+    \n+    print(\"Testing the exact scenario from the PR...\")\n+    \n+    # Create a temporary file to simulate /usr/bin/diff\n+    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n+        # Write some binary content that could cause encoding issues\n+        tmp_file.write(b'\\xcf\\x80\\x00\\x01\\x02\\x03\\x04\\x05')\n+        tmp_file_path = tmp_file.name\n+    \n+    try:\n+        # Test 1: The working case from the PR (method='POST')\n+        print(\"\\n1. Testing working case: method='POST'\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This should work (and did work in the original issue)\n+            req = requests.Request(method='POST', url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str)\n+            assert prepared.method == 'POST'\n+            print(\"   \u2713 Regular string method works\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 2: The problematic case from the PR (method=u'POST')\n+        print(\"\\n2. Testing problematic case: method=u'POST'\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This was causing UnicodeDecodeError in Python 2.7.2\n+            # In Python 3, u'POST' is the same as 'POST', but our fix should still work\n+            unicode_method = 'POST'  # This would be u'POST' in Python 2\n+            req = requests.Request(method=unicode_method, url='http://httpbin.org/post', files=files)\n+            prepared = req.prepare()\n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str)\n+            assert prepared.method == 'POST'\n+            print(\"   \u2713 Unicode string method now works (fixed!)\")\n+        finally:\n+            files['file'].close()\n+        \n+        # Test 3: Test via requests.request() function (the exact API from PR)\n+        print(\"\\n3. Testing via requests.request() function\")\n+        files = {'file': open(tmp_file_path, 'rb')}\n+        try:\n+            # This simulates: requests.request(method=u'POST', url=u'http://httpbin.org/post', files=files)\n+            unicode_method = 'POST'  # This would be u'POST' in Python 2\n+            unicode_url = 'http://httpbin.org/post'  # This would be u'http://httpbin.org/post' in Python 2\n+            \n+            # Create the request using the session (this is what requests.request() does internally)\n+            session = requests.Session()\n+            req = requests.Request(method=unicode_method, url=unicode_url, files=files)\n+            prepared = session.prepare_request(req)\n+            \n+            print(f\"   Method: {repr(prepared.method)} (type: {type(prepared.method)})\")\n+            assert isinstance(prepared.method, builtin_str)\n+            assert prepared.method == 'POST'\n+            print(\"   \u2713 requests.request() with unicode method now works (fixed!)\")\n+        finally:\n+            files['file'].close()\n+        \n+        print(\"\\n\u2705 All PR scenarios work correctly! The fix is successful.\")\n+        \n+    finally:\n+        # Clean up\n+        os.unlink(tmp_file_path)\n+\n+def test_method_conversion_edge_cases():\n+    \"\"\"Test edge cases for method conversion\"\"\"\n+    print(\"\\n4. Testing method conversion edge cases:\")\n+    \n+    # Test various method names that could be unicode\n+    test_methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']\n+    \n+    for method in test_methods:\n+        # Test lowercase\n+        req = requests.Request(method=method.lower(), url='http://example.com')\n+        prepared = req.prepare()\n+        assert prepared.method == method.upper()\n+        assert isinstance(prepared.method, builtin_str)\n+        \n+        # Test mixed case\n+        req = requests.Request(method=method.title(), url='http://example.com')\n+        prepared = req.prepare()\n+        assert prepared.method == method.upper()\n+        assert isinstance(prepared.method, builtin_str)\n+    \n+    print(\"   \u2713 All HTTP methods convert correctly to native strings\")\n+\n+if __name__ == '__main__':\n+    test_pr_scenario()\n+    test_method_conversion_edge_cases()\n+    print(\"\\n\ud83c\udf89 All tests passed! The Unicode method name issue is fixed.\")\n\\ No newline at end of file\n"}
{"model_name_or_path": "openrouter_anthropic_claude-sonnet-4", "instance_id": "psf__requests-1766", "model_patch": "diff --git a/IMPLEMENTATION_SUMMARY.md b/IMPLEMENTATION_SUMMARY.md\nnew file mode 100644\nindex 0000000..3770e1b\n--- /dev/null\n+++ b/IMPLEMENTATION_SUMMARY.md\n@@ -0,0 +1,43 @@\n+# Implementation Summary: Quote qop options in Digest Auth\n+\n+## Problem\n+According to RFC2617, the `qop-options` directive in HTTP Digest Authentication should be quoted with double quotes. The requests library was not quoting the qop value, which caused compatibility issues with some server implementations that are sensitive to RFC compliance.\n+\n+## Root Cause\n+In `/testbed/requests/auth.py`, line 147 was generating the qop part of the digest header without quotes:\n+\n+```python\n+# Before (incorrect)\n+base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+```\n+\n+## Solution\n+Modified line 147 to include quotes around the qop value:\n+\n+```python\n+# After (correct)\n+base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+```\n+\n+## Changes Made\n+- **File**: `/testbed/requests/auth.py`\n+- **Line**: 147\n+- **Change**: Added double quotes around the `auth` value in the qop parameter\n+\n+## Verification\n+1. **RFC2617 Compliance**: The qop value is now properly quoted as required by the specification\n+2. **Curl Compatibility**: Matches the behavior of curl command-line tool\n+3. **Backward Compatibility**: All existing tests pass\n+4. **Server Compatibility**: Should work with servers sensitive to RFC compliance\n+\n+## Test Results\n+- All existing digest auth tests pass\n+- New comprehensive tests verify proper quoting behavior\n+- Edge cases handled correctly\n+- No breaking changes introduced\n+\n+## Example Output\n+**Before**: `qop=auth, nc=00000001, cnonce=\"abc123\"`\n+**After**: `qop=\"auth\", nc=00000001, cnonce=\"abc123\"`\n+\n+The fix ensures that the requests library generates RFC2617-compliant Digest Authentication headers that work with all server implementations.\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000..e972bad\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Script to reproduce the qop quoting issue in Digest Auth.\n+This script will show how the qop value is currently formatted.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+from requests.utils import parse_dict_header\n+\n+def test_qop_formatting():\n+    \"\"\"Test how qop is currently formatted in digest auth header\"\"\"\n+    \n+    # Create a digest auth instance\n+    auth = HTTPDigestAuth('testuser', 'testpass')\n+    \n+    # Simulate a challenge from server with qop\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    # Build digest header\n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    print(\"Current digest header:\")\n+    print(header)\n+    print()\n+    \n+    # Check if qop is quoted in the raw header\n+    if ', qop=\"auth\",' in header or header.endswith(', qop=\"auth\"'):\n+        print(\"\u2713 QOP is properly quoted in the raw header\")\n+    elif ', qop=auth,' in header or header.endswith(', qop=auth'):\n+        print(\"\u2717 QOP is NOT quoted in the raw header\")\n+    else:\n+        print(\"? QOP quoting status unclear\")\n+    print()\n+    \n+    # Parse the header to see individual components\n+    if header.startswith('Digest '):\n+        header_content = header[7:]  # Remove 'Digest ' prefix\n+        parsed = parse_dict_header(header_content)\n+        print(\"Parsed header components:\")\n+        for key, value in parsed.items():\n+            print(\"  {}: {}\".format(key, value))\n+        print()\n+        \n+        # Check if qop is quoted\n+        if 'qop' in parsed:\n+            qop_value = parsed['qop']\n+            print(\"QOP value: '{}'\".format(qop_value))\n+            is_quoted = qop_value.startswith('\"') and qop_value.endswith('\"')\n+            print(\"Is QOP quoted? {}\".format(is_quoted))\n+        else:\n+            print(\"No qop found in parsed header\")\n+\n+if __name__ == '__main__':\n+    test_qop_formatting()\n\\ No newline at end of file\ndiff --git a/requests/auth.py b/requests/auth.py\nindex a3de123..48416e5 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \ndiff --git a/test_before_after.py b/test_before_after.py\nnew file mode 100644\nindex 0000000..9e4f975\n--- /dev/null\n+++ b/test_before_after.py\n@@ -0,0 +1,76 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Demonstrate the before/after behavior of the qop quoting fix.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+def simulate_old_behavior():\n+    \"\"\"Simulate how the code behaved before the fix\"\"\"\n+    # This is what line 147 used to look like:\n+    # base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    \n+    ncvalue = \"00000001\"\n+    cnonce = \"test123\"\n+    old_qop_part = ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    return old_qop_part\n+\n+def simulate_new_behavior():\n+    \"\"\"Simulate how the code behaves after the fix\"\"\"\n+    # This is what line 147 looks like now:\n+    # base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    \n+    ncvalue = \"00000001\"\n+    cnonce = \"test123\"\n+    new_qop_part = ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    return new_qop_part\n+\n+def main():\n+    print(\"Demonstrating the qop quoting fix...\")\n+    print(\"=\" * 50)\n+    \n+    old_part = simulate_old_behavior()\n+    new_part = simulate_new_behavior()\n+    \n+    print(\"BEFORE (without quotes):\")\n+    print(f\"  {old_part}\")\n+    print()\n+    print(\"AFTER (with quotes):\")\n+    print(f\"  {new_part}\")\n+    print()\n+    \n+    print(\"Key differences:\")\n+    print(\"  - Old: qop=auth (no quotes)\")\n+    print(\"  - New: qop=\\\"auth\\\" (with quotes)\")\n+    print()\n+    \n+    print(\"Benefits of the fix:\")\n+    print(\"  \u2713 Complies with RFC2617 specification\")\n+    print(\"  \u2713 Matches curl's behavior\")\n+    print(\"  \u2713 Compatible with servers sensitive to RFC compliance\")\n+    print(\"  \u2713 Maintains backward compatibility\")\n+    \n+    # Test with actual implementation\n+    print(\"\\nTesting with actual implementation:\")\n+    from requests.auth import HTTPDigestAuth\n+    \n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth',\n+        'algorithm': 'MD5'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Generated header: {header}\")\n+    \n+    if 'qop=\"auth\"' in header:\n+        print(\"\u2713 SUCCESS: Fix is working correctly!\")\n+    else:\n+        print(\"\u2717 FAILURE: Fix is not working!\")\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\ndiff --git a/test_curl_comparison.py b/test_curl_comparison.py\nnew file mode 100644\nindex 0000000..d45614e\n--- /dev/null\n+++ b/test_curl_comparison.py\n@@ -0,0 +1,73 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test to compare our implementation with what curl does.\n+According to the PR description, curl also quotes qop values.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_curl_like_behavior():\n+    \"\"\"Test that our implementation behaves like curl\"\"\"\n+    \n+    print(\"Testing curl-like behavior for qop quoting...\")\n+    \n+    # Simulate a typical digest auth challenge\n+    auth = HTTPDigestAuth('user', 'passwd')\n+    auth.chal = {\n+        'realm': 'example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/digest-auth')\n+    \n+    print(\"Generated Digest header:\")\n+    print(header)\n+    print()\n+    \n+    # Check that qop is quoted like curl does\n+    if 'qop=\"auth\"' in header:\n+        print(\"\u2713 SUCCESS: qop is quoted like curl does\")\n+        print(\"  This matches the behavior described in the PR:\")\n+        print(\"  'curl command-line tool also appends these quotes'\")\n+        return True\n+    else:\n+        print(\"\u2717 FAILURE: qop is not quoted like curl\")\n+        return False\n+\n+def test_server_compatibility():\n+    \"\"\"Test that the fix helps with server compatibility\"\"\"\n+    \n+    print(\"\\nTesting server compatibility...\")\n+    print(\"According to the PR: 'some minor server-side implementations\")\n+    print(\"seem to be sensitive on this difference'\")\n+    \n+    # Before fix (simulated)\n+    old_style = 'qop=auth'\n+    new_style = 'qop=\"auth\"'\n+    \n+    print(f\"\\nOld style (before fix): {old_style}\")\n+    print(f\"New style (after fix):  {new_style}\")\n+    print()\n+    print(\"The new style with quotes should be compatible with\")\n+    print(\"servers that are sensitive to RFC2617 compliance.\")\n+    \n+    return True\n+\n+if __name__ == '__main__':\n+    success1 = test_curl_like_behavior()\n+    success2 = test_server_compatibility()\n+    \n+    if success1 and success2:\n+        print(\"\\n\ud83c\udf89 All compatibility tests passed!\")\n+        print(\"The fix successfully addresses the issues mentioned in the PR.\")\n+        sys.exit(0)\n+    else:\n+        print(\"\\n\u274c Some compatibility tests failed!\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000..163cc45\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,103 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test edge cases for the qop quoting fix.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_edge_cases():\n+    \"\"\"Test various edge cases\"\"\"\n+    \n+    print(\"Testing edge cases for qop quoting...\")\n+    \n+    # Edge case 1: Empty qop\n+    print(\"\\nTest 1: Empty qop\")\n+    auth1 = HTTPDigestAuth('user', 'pass')\n+    auth1.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': '',\n+        'algorithm': 'MD5'\n+    }\n+    header1 = auth1.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header1}\")\n+    if header1 is None:\n+        print(\"\u2713 PASS: Empty qop handled correctly (header generation failed)\")\n+    elif 'qop=' not in header1:\n+        print(\"\u2713 PASS: Empty qop handled correctly (no qop in header)\")\n+    else:\n+        print(\"? INFO: Empty qop resulted in header with qop\")\n+    \n+    # Edge case 2: Whitespace in qop\n+    print(\"\\nTest 2: Whitespace in qop\")\n+    auth2 = HTTPDigestAuth('user', 'pass')\n+    auth2.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': ' auth ',\n+        'algorithm': 'MD5'\n+    }\n+    header2 = auth2.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header2}\")\n+    if header2 and 'qop=\"auth\"' in header2:\n+        print(\"\u2713 PASS: Whitespace in qop handled correctly\")\n+    else:\n+        print(\"? INFO: Whitespace in qop may need special handling\")\n+    \n+    # Edge case 3: Case sensitivity\n+    print(\"\\nTest 3: Case sensitivity\")\n+    auth3 = HTTPDigestAuth('user', 'pass')\n+    auth3.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'AUTH',  # uppercase\n+        'algorithm': 'MD5'\n+    }\n+    header3 = auth3.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header3}\")\n+    if header3 is None:\n+        print(\"\u2713 PASS: Uppercase AUTH not supported (as expected)\")\n+    else:\n+        print(\"? INFO: Uppercase AUTH resulted in header\")\n+    \n+    # Edge case 4: Multiple qop with spaces\n+    print(\"\\nTest 4: Multiple qop with spaces\")\n+    auth4 = HTTPDigestAuth('user', 'pass')\n+    auth4.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth, auth-int',  # with space after comma\n+        'algorithm': 'MD5'\n+    }\n+    header4 = auth4.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header4}\")\n+    if header4 and 'qop=\"auth\"' in header4:\n+        print(\"\u2713 PASS: Multiple qop with spaces handled correctly\")\n+    else:\n+        print(\"? INFO: Multiple qop with spaces may need special handling\")\n+    \n+    # Edge case 5: Very long qop list\n+    print(\"\\nTest 5: Long qop list\")\n+    auth5 = HTTPDigestAuth('user', 'pass')\n+    auth5.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth-int,auth,some-other-qop,another-qop',\n+        'algorithm': 'MD5'\n+    }\n+    header5 = auth5.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header5}\")\n+    if header5 and 'qop=\"auth\"' in header5:\n+        print(\"\u2713 PASS: Long qop list handled correctly (found auth)\")\n+    else:\n+        print(\"? INFO: Long qop list handling\")\n+    \n+    print(\"\\n\u2713 Edge case testing completed!\")\n+    return True\n+\n+if __name__ == '__main__':\n+    test_edge_cases()\n\\ No newline at end of file\ndiff --git a/test_qop_fix.py b/test_qop_fix.py\nnew file mode 100644\nindex 0000000..0b2d22c\n--- /dev/null\n+++ b/test_qop_fix.py\n@@ -0,0 +1,165 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Comprehensive test to verify that qop values are properly quoted in Digest Auth.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+import re\n+\n+def test_qop_quoting():\n+    \"\"\"Test that qop values are properly quoted according to RFC2617\"\"\"\n+    \n+    print(\"Testing qop quoting in Digest Auth headers...\")\n+    \n+    # Test case 1: Basic auth qop\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Test 1 - Basic auth qop:\")\n+    print(f\"  Header: {header}\")\n+    \n+    # Check if qop is quoted\n+    qop_match = re.search(r'qop=([^,\\s]+)', header)\n+    if qop_match:\n+        qop_value = qop_match.group(1)\n+        print(f\"  QOP value: {qop_value}\")\n+        if qop_value == '\"auth\"':\n+            print(\"  \u2713 PASS: QOP is properly quoted\")\n+        else:\n+            print(\"  \u2717 FAIL: QOP is not properly quoted\")\n+            return False\n+    else:\n+        print(\"  \u2717 FAIL: QOP not found in header\")\n+        return False\n+    \n+    # Test case 2: Multiple qop values (server supports both auth and auth-int)\n+    auth2 = HTTPDigestAuth('user', 'pass')\n+    auth2.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth,auth-int',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header2 = auth2.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 2 - Multiple qop values:\")\n+    print(f\"  Header: {header2}\")\n+    \n+    qop_match2 = re.search(r'qop=([^,\\s]+)', header2)\n+    if qop_match2:\n+        qop_value2 = qop_match2.group(1)\n+        print(f\"  QOP value: {qop_value2}\")\n+        if qop_value2 == '\"auth\"':\n+            print(\"  \u2713 PASS: QOP is properly quoted (client chose auth)\")\n+        else:\n+            print(\"  \u2717 FAIL: QOP is not properly quoted\")\n+            return False\n+    else:\n+        print(\"  \u2717 FAIL: QOP not found in header\")\n+        return False\n+    \n+    # Test case 3: No qop (legacy mode)\n+    auth3 = HTTPDigestAuth('user', 'pass')\n+    auth3.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header3 = auth3.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 3 - No qop (legacy):\")\n+    print(f\"  Header: {header3}\")\n+    \n+    if 'qop=' not in header3:\n+        print(\"  \u2713 PASS: No QOP in header (legacy mode)\")\n+    else:\n+        print(\"  \u2717 FAIL: QOP found in header when it shouldn't be\")\n+        return False\n+    \n+    # Test case 4: Unsupported qop (auth-int only)\n+    auth4 = HTTPDigestAuth('user', 'pass')\n+    auth4.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth-int',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header4 = auth4.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 4 - Unsupported qop (auth-int only):\")\n+    print(f\"  Header: {header4}\")\n+    \n+    if header4 is None:\n+        print(\"  \u2713 PASS: Header generation failed for unsupported qop\")\n+    else:\n+        print(\"  \u2717 FAIL: Header generated for unsupported qop\")\n+        return False\n+    \n+    print(\"\\n\u2713 All tests passed! QOP values are properly quoted according to RFC2617.\")\n+    return True\n+\n+def test_rfc2617_compliance():\n+    \"\"\"Test compliance with RFC2617 section on qop-options\"\"\"\n+    \n+    print(\"\\nTesting RFC2617 compliance...\")\n+    \n+    # According to RFC2617, qop-options should be quoted\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    # Check that all string values are quoted\n+    string_fields = ['username', 'realm', 'nonce', 'uri', 'response', 'qop', 'cnonce']\n+    unquoted_fields = ['nc']  # nc should not be quoted\n+    \n+    print(\"Checking field quoting:\")\n+    for field in string_fields:\n+        pattern = rf'{field}=\"[^\"]*\"'\n+        if re.search(pattern, header):\n+            print(f\"  \u2713 {field} is properly quoted\")\n+        else:\n+            print(f\"  \u2717 {field} is not properly quoted\")\n+            return False\n+    \n+    for field in unquoted_fields:\n+        pattern = rf'{field}=[^\",\\s]+'\n+        if re.search(pattern, header):\n+            print(f\"  \u2713 {field} is properly unquoted\")\n+        else:\n+            print(f\"  \u2717 {field} should not be quoted\")\n+            return False\n+    \n+    print(\"\u2713 RFC2617 compliance verified!\")\n+    return True\n+\n+if __name__ == '__main__':\n+    success = test_qop_quoting()\n+    if success:\n+        success = test_rfc2617_compliance()\n+    \n+    if success:\n+        print(\"\\n\ud83c\udf89 All tests passed! The fix is working correctly.\")\n+        sys.exit(0)\n+    else:\n+        print(\"\\n\u274c Some tests failed!\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/test_qop_scenarios.py b/test_qop_scenarios.py\nnew file mode 100644\nindex 0000000..2ec59ad\n--- /dev/null\n+++ b/test_qop_scenarios.py\n@@ -0,0 +1,55 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test different qop scenarios to understand the expected behavior.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_qop_scenario(qop_value, description):\n+    \"\"\"Test a specific qop scenario\"\"\"\n+    print(f\"=== Testing: {description} ===\")\n+    print(f\"Server qop: {qop_value}\")\n+    \n+    # Create a digest auth instance\n+    auth = HTTPDigestAuth('testuser', 'testpass')\n+    \n+    # Simulate a challenge from server with different qop values\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': qop_value,\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    # Build digest header\n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    if header:\n+        print(f\"Generated header: {header}\")\n+        # Extract just the qop part\n+        if 'qop=' in header:\n+            qop_start = header.find('qop=')\n+            qop_part = header[qop_start:].split(',')[0]\n+            print(f\"QOP part: {qop_part}\")\n+        else:\n+            print(\"No qop in header\")\n+    else:\n+        print(\"Header generation failed (returned None)\")\n+    \n+    print()\n+\n+def main():\n+    # Test different qop scenarios\n+    test_qop_scenario('auth', 'Single auth qop')\n+    test_qop_scenario('auth-int', 'Single auth-int qop (should fail)')\n+    test_qop_scenario('auth,auth-int', 'Multiple qop values with auth first')\n+    test_qop_scenario('auth-int,auth', 'Multiple qop values with auth second')\n+    test_qop_scenario(None, 'No qop (legacy)')\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\n"}
