{"model_name_or_path": "openrouter_anthropic_claude-sonnet-4", "instance_id": "psf__requests-1766", "model_patch": "diff --git a/IMPLEMENTATION_SUMMARY.md b/IMPLEMENTATION_SUMMARY.md\nnew file mode 100644\nindex 0000000..3770e1b\n--- /dev/null\n+++ b/IMPLEMENTATION_SUMMARY.md\n@@ -0,0 +1,43 @@\n+# Implementation Summary: Quote qop options in Digest Auth\n+\n+## Problem\n+According to RFC2617, the `qop-options` directive in HTTP Digest Authentication should be quoted with double quotes. The requests library was not quoting the qop value, which caused compatibility issues with some server implementations that are sensitive to RFC compliance.\n+\n+## Root Cause\n+In `/testbed/requests/auth.py`, line 147 was generating the qop part of the digest header without quotes:\n+\n+```python\n+# Before (incorrect)\n+base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+```\n+\n+## Solution\n+Modified line 147 to include quotes around the qop value:\n+\n+```python\n+# After (correct)\n+base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+```\n+\n+## Changes Made\n+- **File**: `/testbed/requests/auth.py`\n+- **Line**: 147\n+- **Change**: Added double quotes around the `auth` value in the qop parameter\n+\n+## Verification\n+1. **RFC2617 Compliance**: The qop value is now properly quoted as required by the specification\n+2. **Curl Compatibility**: Matches the behavior of curl command-line tool\n+3. **Backward Compatibility**: All existing tests pass\n+4. **Server Compatibility**: Should work with servers sensitive to RFC compliance\n+\n+## Test Results\n+- All existing digest auth tests pass\n+- New comprehensive tests verify proper quoting behavior\n+- Edge cases handled correctly\n+- No breaking changes introduced\n+\n+## Example Output\n+**Before**: `qop=auth, nc=00000001, cnonce=\"abc123\"`\n+**After**: `qop=\"auth\", nc=00000001, cnonce=\"abc123\"`\n+\n+The fix ensures that the requests library generates RFC2617-compliant Digest Authentication headers that work with all server implementations.\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000..e972bad\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Script to reproduce the qop quoting issue in Digest Auth.\n+This script will show how the qop value is currently formatted.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+from requests.utils import parse_dict_header\n+\n+def test_qop_formatting():\n+    \"\"\"Test how qop is currently formatted in digest auth header\"\"\"\n+    \n+    # Create a digest auth instance\n+    auth = HTTPDigestAuth('testuser', 'testpass')\n+    \n+    # Simulate a challenge from server with qop\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    # Build digest header\n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    print(\"Current digest header:\")\n+    print(header)\n+    print()\n+    \n+    # Check if qop is quoted in the raw header\n+    if ', qop=\"auth\",' in header or header.endswith(', qop=\"auth\"'):\n+        print(\"\u2713 QOP is properly quoted in the raw header\")\n+    elif ', qop=auth,' in header or header.endswith(', qop=auth'):\n+        print(\"\u2717 QOP is NOT quoted in the raw header\")\n+    else:\n+        print(\"? QOP quoting status unclear\")\n+    print()\n+    \n+    # Parse the header to see individual components\n+    if header.startswith('Digest '):\n+        header_content = header[7:]  # Remove 'Digest ' prefix\n+        parsed = parse_dict_header(header_content)\n+        print(\"Parsed header components:\")\n+        for key, value in parsed.items():\n+            print(\"  {}: {}\".format(key, value))\n+        print()\n+        \n+        # Check if qop is quoted\n+        if 'qop' in parsed:\n+            qop_value = parsed['qop']\n+            print(\"QOP value: '{}'\".format(qop_value))\n+            is_quoted = qop_value.startswith('\"') and qop_value.endswith('\"')\n+            print(\"Is QOP quoted? {}\".format(is_quoted))\n+        else:\n+            print(\"No qop found in parsed header\")\n+\n+if __name__ == '__main__':\n+    test_qop_formatting()\n\\ No newline at end of file\ndiff --git a/requests/auth.py b/requests/auth.py\nindex a3de123..48416e5 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \ndiff --git a/test_before_after.py b/test_before_after.py\nnew file mode 100644\nindex 0000000..9e4f975\n--- /dev/null\n+++ b/test_before_after.py\n@@ -0,0 +1,76 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Demonstrate the before/after behavior of the qop quoting fix.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+def simulate_old_behavior():\n+    \"\"\"Simulate how the code behaved before the fix\"\"\"\n+    # This is what line 147 used to look like:\n+    # base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    \n+    ncvalue = \"00000001\"\n+    cnonce = \"test123\"\n+    old_qop_part = ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    return old_qop_part\n+\n+def simulate_new_behavior():\n+    \"\"\"Simulate how the code behaves after the fix\"\"\"\n+    # This is what line 147 looks like now:\n+    # base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    \n+    ncvalue = \"00000001\"\n+    cnonce = \"test123\"\n+    new_qop_part = ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+    return new_qop_part\n+\n+def main():\n+    print(\"Demonstrating the qop quoting fix...\")\n+    print(\"=\" * 50)\n+    \n+    old_part = simulate_old_behavior()\n+    new_part = simulate_new_behavior()\n+    \n+    print(\"BEFORE (without quotes):\")\n+    print(f\"  {old_part}\")\n+    print()\n+    print(\"AFTER (with quotes):\")\n+    print(f\"  {new_part}\")\n+    print()\n+    \n+    print(\"Key differences:\")\n+    print(\"  - Old: qop=auth (no quotes)\")\n+    print(\"  - New: qop=\\\"auth\\\" (with quotes)\")\n+    print()\n+    \n+    print(\"Benefits of the fix:\")\n+    print(\"  \u2713 Complies with RFC2617 specification\")\n+    print(\"  \u2713 Matches curl's behavior\")\n+    print(\"  \u2713 Compatible with servers sensitive to RFC compliance\")\n+    print(\"  \u2713 Maintains backward compatibility\")\n+    \n+    # Test with actual implementation\n+    print(\"\\nTesting with actual implementation:\")\n+    from requests.auth import HTTPDigestAuth\n+    \n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth',\n+        'algorithm': 'MD5'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Generated header: {header}\")\n+    \n+    if 'qop=\"auth\"' in header:\n+        print(\"\u2713 SUCCESS: Fix is working correctly!\")\n+    else:\n+        print(\"\u2717 FAILURE: Fix is not working!\")\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\ndiff --git a/test_curl_comparison.py b/test_curl_comparison.py\nnew file mode 100644\nindex 0000000..d45614e\n--- /dev/null\n+++ b/test_curl_comparison.py\n@@ -0,0 +1,73 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test to compare our implementation with what curl does.\n+According to the PR description, curl also quotes qop values.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_curl_like_behavior():\n+    \"\"\"Test that our implementation behaves like curl\"\"\"\n+    \n+    print(\"Testing curl-like behavior for qop quoting...\")\n+    \n+    # Simulate a typical digest auth challenge\n+    auth = HTTPDigestAuth('user', 'passwd')\n+    auth.chal = {\n+        'realm': 'example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/digest-auth')\n+    \n+    print(\"Generated Digest header:\")\n+    print(header)\n+    print()\n+    \n+    # Check that qop is quoted like curl does\n+    if 'qop=\"auth\"' in header:\n+        print(\"\u2713 SUCCESS: qop is quoted like curl does\")\n+        print(\"  This matches the behavior described in the PR:\")\n+        print(\"  'curl command-line tool also appends these quotes'\")\n+        return True\n+    else:\n+        print(\"\u2717 FAILURE: qop is not quoted like curl\")\n+        return False\n+\n+def test_server_compatibility():\n+    \"\"\"Test that the fix helps with server compatibility\"\"\"\n+    \n+    print(\"\\nTesting server compatibility...\")\n+    print(\"According to the PR: 'some minor server-side implementations\")\n+    print(\"seem to be sensitive on this difference'\")\n+    \n+    # Before fix (simulated)\n+    old_style = 'qop=auth'\n+    new_style = 'qop=\"auth\"'\n+    \n+    print(f\"\\nOld style (before fix): {old_style}\")\n+    print(f\"New style (after fix):  {new_style}\")\n+    print()\n+    print(\"The new style with quotes should be compatible with\")\n+    print(\"servers that are sensitive to RFC2617 compliance.\")\n+    \n+    return True\n+\n+if __name__ == '__main__':\n+    success1 = test_curl_like_behavior()\n+    success2 = test_server_compatibility()\n+    \n+    if success1 and success2:\n+        print(\"\\n\ud83c\udf89 All compatibility tests passed!\")\n+        print(\"The fix successfully addresses the issues mentioned in the PR.\")\n+        sys.exit(0)\n+    else:\n+        print(\"\\n\u274c Some compatibility tests failed!\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000..163cc45\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,103 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test edge cases for the qop quoting fix.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_edge_cases():\n+    \"\"\"Test various edge cases\"\"\"\n+    \n+    print(\"Testing edge cases for qop quoting...\")\n+    \n+    # Edge case 1: Empty qop\n+    print(\"\\nTest 1: Empty qop\")\n+    auth1 = HTTPDigestAuth('user', 'pass')\n+    auth1.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': '',\n+        'algorithm': 'MD5'\n+    }\n+    header1 = auth1.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header1}\")\n+    if header1 is None:\n+        print(\"\u2713 PASS: Empty qop handled correctly (header generation failed)\")\n+    elif 'qop=' not in header1:\n+        print(\"\u2713 PASS: Empty qop handled correctly (no qop in header)\")\n+    else:\n+        print(\"? INFO: Empty qop resulted in header with qop\")\n+    \n+    # Edge case 2: Whitespace in qop\n+    print(\"\\nTest 2: Whitespace in qop\")\n+    auth2 = HTTPDigestAuth('user', 'pass')\n+    auth2.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': ' auth ',\n+        'algorithm': 'MD5'\n+    }\n+    header2 = auth2.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header2}\")\n+    if header2 and 'qop=\"auth\"' in header2:\n+        print(\"\u2713 PASS: Whitespace in qop handled correctly\")\n+    else:\n+        print(\"? INFO: Whitespace in qop may need special handling\")\n+    \n+    # Edge case 3: Case sensitivity\n+    print(\"\\nTest 3: Case sensitivity\")\n+    auth3 = HTTPDigestAuth('user', 'pass')\n+    auth3.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'AUTH',  # uppercase\n+        'algorithm': 'MD5'\n+    }\n+    header3 = auth3.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header3}\")\n+    if header3 is None:\n+        print(\"\u2713 PASS: Uppercase AUTH not supported (as expected)\")\n+    else:\n+        print(\"? INFO: Uppercase AUTH resulted in header\")\n+    \n+    # Edge case 4: Multiple qop with spaces\n+    print(\"\\nTest 4: Multiple qop with spaces\")\n+    auth4 = HTTPDigestAuth('user', 'pass')\n+    auth4.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth, auth-int',  # with space after comma\n+        'algorithm': 'MD5'\n+    }\n+    header4 = auth4.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header4}\")\n+    if header4 and 'qop=\"auth\"' in header4:\n+        print(\"\u2713 PASS: Multiple qop with spaces handled correctly\")\n+    else:\n+        print(\"? INFO: Multiple qop with spaces may need special handling\")\n+    \n+    # Edge case 5: Very long qop list\n+    print(\"\\nTest 5: Long qop list\")\n+    auth5 = HTTPDigestAuth('user', 'pass')\n+    auth5.chal = {\n+        'realm': 'test',\n+        'nonce': 'abc123',\n+        'qop': 'auth-int,auth,some-other-qop,another-qop',\n+        'algorithm': 'MD5'\n+    }\n+    header5 = auth5.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Header: {header5}\")\n+    if header5 and 'qop=\"auth\"' in header5:\n+        print(\"\u2713 PASS: Long qop list handled correctly (found auth)\")\n+    else:\n+        print(\"? INFO: Long qop list handling\")\n+    \n+    print(\"\\n\u2713 Edge case testing completed!\")\n+    return True\n+\n+if __name__ == '__main__':\n+    test_edge_cases()\n\\ No newline at end of file\ndiff --git a/test_qop_fix.py b/test_qop_fix.py\nnew file mode 100644\nindex 0000000..0b2d22c\n--- /dev/null\n+++ b/test_qop_fix.py\n@@ -0,0 +1,165 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Comprehensive test to verify that qop values are properly quoted in Digest Auth.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+import re\n+\n+def test_qop_quoting():\n+    \"\"\"Test that qop values are properly quoted according to RFC2617\"\"\"\n+    \n+    print(\"Testing qop quoting in Digest Auth headers...\")\n+    \n+    # Test case 1: Basic auth qop\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"Test 1 - Basic auth qop:\")\n+    print(f\"  Header: {header}\")\n+    \n+    # Check if qop is quoted\n+    qop_match = re.search(r'qop=([^,\\s]+)', header)\n+    if qop_match:\n+        qop_value = qop_match.group(1)\n+        print(f\"  QOP value: {qop_value}\")\n+        if qop_value == '\"auth\"':\n+            print(\"  \u2713 PASS: QOP is properly quoted\")\n+        else:\n+            print(\"  \u2717 FAIL: QOP is not properly quoted\")\n+            return False\n+    else:\n+        print(\"  \u2717 FAIL: QOP not found in header\")\n+        return False\n+    \n+    # Test case 2: Multiple qop values (server supports both auth and auth-int)\n+    auth2 = HTTPDigestAuth('user', 'pass')\n+    auth2.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth,auth-int',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header2 = auth2.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 2 - Multiple qop values:\")\n+    print(f\"  Header: {header2}\")\n+    \n+    qop_match2 = re.search(r'qop=([^,\\s]+)', header2)\n+    if qop_match2:\n+        qop_value2 = qop_match2.group(1)\n+        print(f\"  QOP value: {qop_value2}\")\n+        if qop_value2 == '\"auth\"':\n+            print(\"  \u2713 PASS: QOP is properly quoted (client chose auth)\")\n+        else:\n+            print(\"  \u2717 FAIL: QOP is not properly quoted\")\n+            return False\n+    else:\n+        print(\"  \u2717 FAIL: QOP not found in header\")\n+        return False\n+    \n+    # Test case 3: No qop (legacy mode)\n+    auth3 = HTTPDigestAuth('user', 'pass')\n+    auth3.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header3 = auth3.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 3 - No qop (legacy):\")\n+    print(f\"  Header: {header3}\")\n+    \n+    if 'qop=' not in header3:\n+        print(\"  \u2713 PASS: No QOP in header (legacy mode)\")\n+    else:\n+        print(\"  \u2717 FAIL: QOP found in header when it shouldn't be\")\n+        return False\n+    \n+    # Test case 4: Unsupported qop (auth-int only)\n+    auth4 = HTTPDigestAuth('user', 'pass')\n+    auth4.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth-int',\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header4 = auth4.build_digest_header('GET', 'http://example.com/test')\n+    print(f\"\\nTest 4 - Unsupported qop (auth-int only):\")\n+    print(f\"  Header: {header4}\")\n+    \n+    if header4 is None:\n+        print(\"  \u2713 PASS: Header generation failed for unsupported qop\")\n+    else:\n+        print(\"  \u2717 FAIL: Header generated for unsupported qop\")\n+        return False\n+    \n+    print(\"\\n\u2713 All tests passed! QOP values are properly quoted according to RFC2617.\")\n+    return True\n+\n+def test_rfc2617_compliance():\n+    \"\"\"Test compliance with RFC2617 section on qop-options\"\"\"\n+    \n+    print(\"\\nTesting RFC2617 compliance...\")\n+    \n+    # According to RFC2617, qop-options should be quoted\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'algorithm': 'MD5'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    # Check that all string values are quoted\n+    string_fields = ['username', 'realm', 'nonce', 'uri', 'response', 'qop', 'cnonce']\n+    unquoted_fields = ['nc']  # nc should not be quoted\n+    \n+    print(\"Checking field quoting:\")\n+    for field in string_fields:\n+        pattern = rf'{field}=\"[^\"]*\"'\n+        if re.search(pattern, header):\n+            print(f\"  \u2713 {field} is properly quoted\")\n+        else:\n+            print(f\"  \u2717 {field} is not properly quoted\")\n+            return False\n+    \n+    for field in unquoted_fields:\n+        pattern = rf'{field}=[^\",\\s]+'\n+        if re.search(pattern, header):\n+            print(f\"  \u2713 {field} is properly unquoted\")\n+        else:\n+            print(f\"  \u2717 {field} should not be quoted\")\n+            return False\n+    \n+    print(\"\u2713 RFC2617 compliance verified!\")\n+    return True\n+\n+if __name__ == '__main__':\n+    success = test_qop_quoting()\n+    if success:\n+        success = test_rfc2617_compliance()\n+    \n+    if success:\n+        print(\"\\n\ud83c\udf89 All tests passed! The fix is working correctly.\")\n+        sys.exit(0)\n+    else:\n+        print(\"\\n\u274c Some tests failed!\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/test_qop_scenarios.py b/test_qop_scenarios.py\nnew file mode 100644\nindex 0000000..2ec59ad\n--- /dev/null\n+++ b/test_qop_scenarios.py\n@@ -0,0 +1,55 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test different qop scenarios to understand the expected behavior.\n+\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, '/testbed')\n+\n+from requests.auth import HTTPDigestAuth\n+\n+def test_qop_scenario(qop_value, description):\n+    \"\"\"Test a specific qop scenario\"\"\"\n+    print(f\"=== Testing: {description} ===\")\n+    print(f\"Server qop: {qop_value}\")\n+    \n+    # Create a digest auth instance\n+    auth = HTTPDigestAuth('testuser', 'testpass')\n+    \n+    # Simulate a challenge from server with different qop values\n+    auth.chal = {\n+        'realm': 'test@example.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': qop_value,\n+        'algorithm': 'MD5',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    # Build digest header\n+    header = auth.build_digest_header('GET', 'http://example.com/test')\n+    \n+    if header:\n+        print(f\"Generated header: {header}\")\n+        # Extract just the qop part\n+        if 'qop=' in header:\n+            qop_start = header.find('qop=')\n+            qop_part = header[qop_start:].split(',')[0]\n+            print(f\"QOP part: {qop_part}\")\n+        else:\n+            print(\"No qop in header\")\n+    else:\n+        print(\"Header generation failed (returned None)\")\n+    \n+    print()\n+\n+def main():\n+    # Test different qop scenarios\n+    test_qop_scenario('auth', 'Single auth qop')\n+    test_qop_scenario('auth-int', 'Single auth-int qop (should fail)')\n+    test_qop_scenario('auth,auth-int', 'Multiple qop values with auth first')\n+    test_qop_scenario('auth-int,auth', 'Multiple qop values with auth second')\n+    test_qop_scenario(None, 'No qop (legacy)')\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\n"}