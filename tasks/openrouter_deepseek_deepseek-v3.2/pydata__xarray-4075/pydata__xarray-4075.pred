{"model_name_or_path": "openrouter_deepseek_deepseek-v3.2", "instance_id": "pydata__xarray-4075", "model_patch": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 00000000..f3e0c6a6\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,41 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing boolean weights issue...\")\n+dta = xr.DataArray([1., 1., 1.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))\n+\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Weights dtype: {wgt.dtype}\")\n+\n+result = dta.weighted(wgt).mean()\n+print(f\"\\nResult: {result.values}\")\n+print(f\"Expected: 1.0\")\n+\n+# Let's also test the sum_of_weights calculation\n+print(\"\\n--- Testing sum_of_weights calculation ---\")\n+mask = dta.notnull()\n+print(f\"mask: {mask.values}\")\n+print(f\"mask dtype: {mask.dtype}\")\n+\n+# Test dot product directly\n+from xarray.core.computation import dot\n+dot_result = dot(mask, wgt)\n+print(f\"\\ndot(mask, wgt): {dot_result.values}\")\n+print(f\"dot(mask, wgt) dtype: {dot_result.dtype}\")\n+\n+# Test with conversion\n+dot_result_converted = dot(mask, wgt * 1)\n+print(f\"\\ndot(mask, wgt * 1): {dot_result_converted.values}\")\n+print(f\"dot(mask, wgt * 1) dtype: {dot_result_converted.dtype}\")\n+\n+# Let's also test weighted sum\n+weighted_sum = dta.weighted(wgt).sum()\n+print(f\"\\nWeighted sum: {weighted_sum.values}\")\n+print(f\"Expected weighted sum: 2.0\")\n+\n+# Test sum_of_weights method\n+sum_of_weights = dta.weighted(wgt).sum_of_weights()\n+print(f\"\\nsum_of_weights(): {sum_of_weights.values}\")\n+print(f\"Expected sum_of_weights: 2.0\")\n\\ No newline at end of file\ndiff --git a/test_dot_boolean_math.py b/test_dot_boolean_math.py\nnew file mode 100644\nindex 00000000..6c87301e\n--- /dev/null\n+++ b/test_dot_boolean_math.py\n@@ -0,0 +1,23 @@\n+import numpy as np\n+\n+# Test numpy dot with boolean arrays\n+a = np.array([True, True, True])\n+b = np.array([True, True, False])\n+\n+print(f\"a: {a}\")\n+print(f\"b: {b}\")\n+print(f\"np.dot(a, b): {np.dot(a, b)}\")\n+print(f\"np.dot(a, b).dtype: {np.dot(a, b).dtype}\")\n+print(f\"float(np.dot(a, b)): {float(np.dot(a, b))}\")\n+\n+# What's actually happening?\n+print(f\"\\na.astype(int): {a.astype(int)}\")\n+print(f\"b.astype(int): {b.astype(int)}\")\n+print(f\"np.dot(a.astype(int), b.astype(int)): {np.dot(a.astype(int), b.astype(int))}\")\n+\n+# Test with einsum\n+print(f\"\\nnp.einsum('i,i->', a, b): {np.einsum('i,i->', a, b)}\")\n+print(f\"np.einsum('i,i->', a, b).dtype: {np.einsum('i,i->', a, b).dtype}\")\n+\n+# So numpy.dot with boolean arrays returns a boolean scalar!\n+# True is being treated as 1, False as 0, but the result is boolean True (1)\n\\ No newline at end of file\ndiff --git a/test_dot_types.py b/test_dot_types.py\nnew file mode 100644\nindex 00000000..619baa30\n--- /dev/null\n+++ b/test_dot_types.py\n@@ -0,0 +1,39 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test dot with different dtype combinations\n+print(\"Testing dot with different dtype combinations:\")\n+\n+# Boolean x Boolean\n+mask = xr.DataArray([True, True, True])\n+weights = xr.DataArray([True, True, False])\n+result = xr.dot(mask, weights)\n+print(f\"Boolean x Boolean: {result.values}, dtype: {result.dtype}\")\n+\n+# Boolean x Int\n+weights_int = xr.DataArray([1, 1, 0])\n+result = xr.dot(mask, weights_int)\n+print(f\"Boolean x Int: {result.values}, dtype: {result.dtype}\")\n+\n+# Boolean x Float\n+weights_float = xr.DataArray([1.0, 1.0, 0.0])\n+result = xr.dot(mask, weights_float)\n+print(f\"Boolean x Float: {result.values}, dtype: {result.dtype}\")\n+\n+# Int x Boolean\n+mask_int = xr.DataArray([1, 1, 1])\n+result = xr.dot(mask_int, weights)\n+print(f\"Int x Boolean: {result.values}, dtype: {result.dtype}\")\n+\n+# Float x Boolean\n+mask_float = xr.DataArray([1.0, 1.0, 1.0])\n+result = xr.dot(mask_float, weights)\n+print(f\"Float x Boolean: {result.values}, dtype: {result.dtype}\")\n+\n+# Test with conversion\n+print(\"\\nWith conversion:\")\n+result = xr.dot(mask, weights.astype(float))\n+print(f\"Boolean x Boolean (converted to float): {result.values}, dtype: {result.dtype}\")\n+\n+result = xr.dot(mask.astype(float), weights)\n+print(f\"Boolean (converted to float) x Boolean: {result.values}, dtype: {result.dtype}\")\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 00000000..8bce830f\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,86 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing edge cases for boolean weights...\")\n+\n+# Test 1: Original issue\n+print(\"\\n=== Test 1: Original issue ===\")\n+dta = xr.DataArray([1., 1., 1.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: 1.0\")\n+assert np.isclose(result.values, 1.0), f\"Expected 1.0, got {result.values}\"\n+\n+# Test 2: Boolean data with boolean weights\n+print(\"\\n=== Test 2: Boolean data with boolean weights ===\")\n+dta = xr.DataArray([True, True, True])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).sum()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: 2.0\")\n+assert np.isclose(result.values, 2.0), f\"Expected 2.0, got {result.values}\"\n+\n+# Test 3: Mixed types\n+print(\"\\n=== Test 3: Integer data with boolean weights ===\")\n+dta = xr.DataArray([1, 2, 3])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: 1.5\")\n+assert np.isclose(result.values, 1.5), f\"Expected 1.5, got {result.values}\"\n+\n+# Test 4: All False weights\n+print(\"\\n=== Test 4: All False weights ===\")\n+dta = xr.DataArray([1., 2., 3.])\n+wgt = xr.DataArray(np.array([0, 0, 0], dtype=bool))\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: nan\")\n+assert np.isnan(result.values), f\"Expected nan, got {result.values}\"\n+\n+# Test 5: With NaN in data\n+print(\"\\n=== Test 5: With NaN in data ===\")\n+dta = xr.DataArray([1., np.nan, 3.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).mean(skipna=True)\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: 1.0\")\n+assert np.isclose(result.values, 1.0), f\"Expected 1.0, got {result.values}\"\n+\n+# Test 6: sum_of_weights with boolean weights\n+print(\"\\n=== Test 6: sum_of_weights with boolean weights ===\")\n+dta = xr.DataArray([1., 2., 3.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).sum_of_weights()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"sum_of_weights: {result.values}\")\n+print(f\"Expected: 2.0\")\n+assert np.isclose(result.values, 2.0), f\"Expected 2.0, got {result.values}\"\n+\n+# Test 7: Dataset with boolean weights\n+print(\"\\n=== Test 7: Dataset with boolean weights ===\")\n+ds = xr.Dataset({'a': xr.DataArray([1., 2., 3.]), 'b': xr.DataArray([4., 5., 6.])})\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = ds.weighted(wgt).mean()\n+print(f\"Dataset a: {ds.a.values}\")\n+print(f\"Dataset b: {ds.b.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result a: {result.a.values}\")\n+print(f\"Result b: {result.b.values}\")\n+print(f\"Expected a: 1.5, b: 4.5\")\n+assert np.isclose(result.a.values, 1.5), f\"Expected 1.5, got {result.a.values}\"\n+assert np.isclose(result.b.values, 4.5), f\"Expected 4.5, got {result.b.values}\"\n+\n+print(\"\\n=== All tests passed! ===\")\n\\ No newline at end of file\ndiff --git a/test_einsum.py b/test_einsum.py\nnew file mode 100644\nindex 00000000..2fcab783\n--- /dev/null\n+++ b/test_einsum.py\n@@ -0,0 +1,32 @@\n+import numpy as np\n+\n+# Test numpy einsum with boolean arrays\n+a = np.array([True, True, True])\n+b = np.array([True, True, False])\n+\n+print(\"Testing numpy einsum with boolean arrays:\")\n+print(f\"a: {a}\")\n+print(f\"b: {b}\")\n+print(f\"np.einsum('i,i->', a, b): {np.einsum('i,i->', a, b)}\")\n+print(f\"Type: {type(np.einsum('i,i->', a, b))}\")\n+\n+# Test with int conversion\n+print(\"\\nWith int conversion:\")\n+print(f\"np.einsum('i,i->', a.astype(int), b.astype(int)): {np.einsum('i,i->', a.astype(int), b.astype(int))}\")\n+print(f\"Type: {type(np.einsum('i,i->', a.astype(int), b.astype(int)))}\")\n+\n+# Test with float conversion\n+print(\"\\nWith float conversion:\")\n+print(f\"np.einsum('i,i->', a.astype(float), b.astype(float)): {np.einsum('i,i->', a.astype(float), b.astype(float))}\")\n+print(f\"Type: {type(np.einsum('i,i->', a.astype(float), b.astype(float)))}\")\n+\n+# Test dot product\n+print(\"\\nTesting dot product:\")\n+print(f\"np.dot(a, b): {np.dot(a, b)}\")\n+print(f\"Type: {type(np.dot(a, b))}\")\n+\n+print(f\"np.dot(a.astype(int), b): {np.dot(a.astype(int), b)}\")\n+print(f\"Type: {type(np.dot(a.astype(int), b))}\")\n+\n+print(f\"np.dot(a, b.astype(int)): {np.dot(a, b.astype(int))}\")\n+print(f\"Type: {type(np.dot(a, b.astype(int)))}\")\n\\ No newline at end of file\ndiff --git a/test_integer_overflow.py b/test_integer_overflow.py\nnew file mode 100644\nindex 00000000..3788455a\n--- /dev/null\n+++ b/test_integer_overflow.py\n@@ -0,0 +1,32 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing for integer overflow issues...\")\n+\n+# Test with large integer values\n+print(\"\\n=== Test 1: Large integer values ===\")\n+da = xr.DataArray([1000000, 2000000, 3000000], dtype=np.int32)\n+wgt = xr.DataArray([1000000, 1000000, 0], dtype=np.int32)\n+result = da.weighted(wgt).mean()\n+print(f\"Data: {da.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Result dtype: {result.dtype}\")\n+expected = (1000000*1000000 + 2000000*1000000) / (1000000 + 1000000)\n+print(f\"Expected: {expected}\")\n+assert np.isclose(result.values, expected), f\"Expected {expected}, got {result.values}\"\n+\n+# Test with boolean weights and large integer data\n+print(\"\\n=== Test 2: Boolean weights with large integer data ===\")\n+da = xr.DataArray([1000000, 2000000, 3000000], dtype=np.int64)\n+wgt = xr.DataArray([True, True, False])\n+result = da.weighted(wgt).mean()\n+print(f\"Data: {da.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Result dtype: {result.dtype}\")\n+expected = (1000000 + 2000000) / 2\n+print(f\"Expected: {expected}\")\n+assert np.isclose(result.values, expected), f\"Expected {expected}, got {result.values}\"\n+\n+print(\"\\n=== All tests passed! ===\")\n\\ No newline at end of file\ndiff --git a/test_integer_weights.py b/test_integer_weights.py\nnew file mode 100644\nindex 00000000..d2bf4e1c\n--- /dev/null\n+++ b/test_integer_weights.py\n@@ -0,0 +1,42 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing integer weights...\")\n+\n+# Test with integer weights (not boolean)\n+print(\"\\n=== Test 1: Integer weights ===\")\n+dta = xr.DataArray([1., 2., 3.])\n+wgt = xr.DataArray([1, 2, 3])  # Integer weights\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+print(f\"Expected: (1*1 + 2*2 + 3*3) / (1+2+3) = 14/6 = 2.333...\")\n+expected = (1*1 + 2*2 + 3*3) / (1+2+3)\n+assert np.isclose(result.values, expected), f\"Expected {expected}, got {result.values}\"\n+\n+# Test with float weights\n+print(\"\\n=== Test 2: Float weights ===\")\n+dta = xr.DataArray([1., 2., 3.])\n+wgt = xr.DataArray([1.5, 2.5, 3.5])  # Float weights\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+expected = (1*1.5 + 2*2.5 + 3*3.5) / (1.5+2.5+3.5)\n+assert np.isclose(result.values, expected), f\"Expected {expected}, got {result.values}\"\n+\n+# Test with complex data types\n+print(\"\\n=== Test 3: Complex data types ===\")\n+dta = xr.DataArray([1+2j, 3+4j, 5+6j])\n+wgt = xr.DataArray([1., 2., 3.])  # Float weights\n+result = dta.weighted(wgt).mean()\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result: {result.values}\")\n+expected_numerator = (1+2j)*1 + (3+4j)*2 + (5+6j)*3\n+expected_denominator = 1 + 2 + 3\n+expected = expected_numerator / expected_denominator\n+assert np.isclose(result.values, expected), f\"Expected {expected}, got {result.values}\"\n+\n+print(\"\\n=== All tests passed! ===\")\n\\ No newline at end of file\ndiff --git a/test_skipna_behavior.py b/test_skipna_behavior.py\nnew file mode 100644\nindex 00000000..ccd45811\n--- /dev/null\n+++ b/test_skipna_behavior.py\n@@ -0,0 +1,51 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing skipna behavior with boolean weights...\")\n+\n+# Test with NaN in data and boolean weights\n+print(\"\\n=== Test 1: skipna=True with boolean weights ===\")\n+dta = xr.DataArray([1., np.nan, 3.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).mean(skipna=True)\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result (skipna=True): {result.values}\")\n+print(f\"Expected: 1.0 (only first element contributes)\")\n+assert np.isclose(result.values, 1.0), f\"Expected 1.0, got {result.values}\"\n+\n+# Test with skipna=False\n+print(\"\\n=== Test 2: skipna=False with boolean weights ===\")\n+result = dta.weighted(wgt).mean(skipna=False)\n+print(f\"Result (skipna=False): {result.values}\")\n+print(f\"Expected: nan (second element is nan)\")\n+assert np.isnan(result.values), f\"Expected nan, got {result.values}\"\n+\n+# Test with all NaN and boolean weights\n+print(\"\\n=== Test 3: All NaN with boolean weights ===\")\n+dta = xr.DataArray([np.nan, np.nan, np.nan])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).mean(skipna=True)\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result (skipna=True): {result.values}\")\n+print(f\"Expected: nan (all data is nan)\")\n+assert np.isnan(result.values), f\"Expected nan, got {result.values}\"\n+\n+# Test weighted sum with skipna\n+print(\"\\n=== Test 4: Weighted sum with skipna and boolean weights ===\")\n+dta = xr.DataArray([1., np.nan, 3.])\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))\n+result = dta.weighted(wgt).sum(skipna=True)\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+print(f\"Result (skipna=True): {result.values}\")\n+print(f\"Expected: 1.0 (only first element contributes)\")\n+assert np.isclose(result.values, 1.0), f\"Expected 1.0, got {result.values}\"\n+\n+result = dta.weighted(wgt).sum(skipna=False)\n+print(f\"Result (skipna=False): {result.values}\")\n+print(f\"Expected: nan (second element is nan)\")\n+assert np.isnan(result.values), f\"Expected nan, got {result.values}\"\n+\n+print(\"\\n=== All tests passed! ===\")\n\\ No newline at end of file\ndiff --git a/test_various_dtypes.py b/test_various_dtypes.py\nnew file mode 100644\nindex 00000000..ec3f0d22\n--- /dev/null\n+++ b/test_various_dtypes.py\n@@ -0,0 +1,15 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing weighted operations with various dtypes...\")\n+\n+dtypes = [bool, np.int8, np.int16, np.int32, np.int64, np.float32, np.float64, np.complex64, np.complex128]\n+\n+for dtype in dtypes:\n+    da = xr.DataArray([1, 2, 3]).astype(dtype)\n+    wgt = xr.DataArray([1, 1, 0]).astype(dtype if dtype != bool else bool)\n+    try:\n+        result = da.weighted(wgt).mean()\n+        print(f\"{dtype.__name__}: {result.values} ({result.dtype})\")\n+    except Exception as e:\n+        print(f\"{dtype.__name__}: Error - {e}\")\n\\ No newline at end of file\ndiff --git a/test_weighted_sum_boolean.py b/test_weighted_sum_boolean.py\nnew file mode 100644\nindex 00000000..561c890d\n--- /dev/null\n+++ b/test_weighted_sum_boolean.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing weighted sum with boolean data and boolean weights...\")\n+dta = xr.DataArray([True, True, True])  # Boolean data\n+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))\n+\n+print(f\"Data: {dta.values}\")\n+print(f\"Weights: {wgt.values}\")\n+\n+result = dta.weighted(wgt).sum()\n+print(f\"\\nWeighted sum: {result.values}\")\n+print(f\"Expected: 2.0 (sum of weights where data is True)\")\n+\n+# Also test with float data and boolean weights\n+print(\"\\n\\nTesting weighted sum with float data and boolean weights...\")\n+dta2 = xr.DataArray([1.0, 2.0, 3.0])\n+wgt2 = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))\n+\n+print(f\"Data: {dta2.values}\")\n+print(f\"Weights: {wgt2.values}\")\n+\n+result2 = dta2.weighted(wgt2).sum()\n+print(f\"\\nWeighted sum: {result2.values}\")\n+print(f\"Expected: 3.0 (1.0*1 + 2.0*1 + 3.0*0)\")\n+\n+# Test weighted mean with float data and boolean weights\n+print(\"\\n\\nTesting weighted mean with float data and boolean weights...\")\n+dta3 = xr.DataArray([1.0, 2.0, 3.0])\n+wgt3 = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))\n+\n+print(f\"Data: {dta3.values}\")\n+print(f\"Weights: {wgt3.values}\")\n+\n+result3 = dta3.weighted(wgt3).mean()\n+print(f\"\\nWeighted mean: {result3.values}\")\n+print(f\"Expected: 1.5 ((1.0*1 + 2.0*1 + 3.0*0) / 2)\")\n\\ No newline at end of file\ndiff --git a/xarray/core/weighted.py b/xarray/core/weighted.py\nindex 996d2e4c..0b713cea 100644\n--- a/xarray/core/weighted.py\n+++ b/xarray/core/weighted.py\n@@ -129,6 +129,13 @@ class Weighted:\n         if skipna or (skipna is None and da.dtype.kind in \"cfO\"):\n             da = da.fillna(0.0)\n \n+        # Convert boolean arrays to float to avoid boolean output from dot\n+        # when both inputs are boolean\n+        if da.dtype == bool:\n+            da = da.astype(float)\n+        if weights.dtype == bool:\n+            weights = weights.astype(float)\n+\n         # `dot` does not broadcast arrays, so this avoids creating a large\n         # DataArray (if `weights` has additional dimensions)\n         # maybe add fasttrack (`(da * weights).sum(dims=dim, skipna=skipna)`)\n"}