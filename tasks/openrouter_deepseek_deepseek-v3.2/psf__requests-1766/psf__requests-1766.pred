{"model_name_or_path": "openrouter_deepseek_deepseek-v3.2", "instance_id": "psf__requests-1766", "model_patch": "diff --git a/requests/auth.py b/requests/auth.py\nindex a3de123..48416e5 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \ndiff --git a/test_digest_comprehensive.py b/test_digest_comprehensive.py\nnew file mode 100644\nindex 0000000..a83024e\n--- /dev/null\n+++ b/test_digest_comprehensive.py\n@@ -0,0 +1,68 @@\n+#!/usr/bin/env python\n+import requests\n+from requests.auth import HTTPDigestAuth\n+\n+# Test various qop scenarios\n+def test_qop_scenario(qop_value, description):\n+    print(f\"\\n--- Testing: {description} (qop='{qop_value}') ---\")\n+    \n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'testrealm@host.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': qop_value,\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/')\n+    print(f\"Generated header: {header}\")\n+    \n+    if header is None:\n+        print(\"\u2713 No header generated (auth-int not supported)\")\n+        return None\n+    \n+    # Check if qop is quoted\n+    if 'qop=\"auth\"' in header:\n+        print(\"\u2713 qop is properly quoted\")\n+    elif 'qop=auth' in header:\n+        print(\"\u2717 qop is NOT quoted (should be qop=\\\"auth\\\")\")\n+    else:\n+        print(\"? qop not found in header\")\n+    \n+    return header\n+\n+# Test cases\n+print(\"=== Testing Digest Auth qop quoting ===\")\n+print(\"According to RFC 2617, qop value should be quoted.\")\n+print()\n+\n+# Test 1: qop='auth'\n+header1 = test_qop_scenario('auth', 'Single qop value')\n+\n+# Test 2: qop='auth,auth-int'\n+header2 = test_qop_scenario('auth,auth-int', 'Multiple qop values from server')\n+\n+# Test 3: qop='auth-int'\n+header3 = test_qop_scenario('auth-int', 'Only auth-int (should not include qop in response)')\n+\n+# Test 4: No qop\n+print(\"\\n--- Testing: No qop ---\")\n+auth = HTTPDigestAuth('user', 'pass')\n+auth.chal = {\n+    'realm': 'testrealm@host.com',\n+    'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+    'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+}\n+header4 = auth.build_digest_header('GET', 'http://example.com/')\n+print(f\"Generated header: {header4}\")\n+if 'qop=' in header4:\n+    print(\"\u2717 qop should not be present when not in challenge\")\n+else:\n+    print(\"\u2713 No qop in header (correct)\")\n+\n+print(\"\\n=== Summary ===\")\n+print(\"The issue is on line 147 of requests/auth.py:\")\n+print(\"  Current: ', qop=auth, nc=%s, cnonce=\\\"%s\\\"'\")\n+print(\"  Should be: ', qop=\\\"auth\\\", nc=%s, cnonce=\\\"%s\\\"'\")\n+print(\"\\nNote: The client should always send 'auth' as the qop value (quoted)\")\n+print(\"even if the server offers multiple options like 'auth,auth-int'.\")\n\\ No newline at end of file\ndiff --git a/test_digest_edge_cases.py b/test_digest_edge_cases.py\nnew file mode 100644\nindex 0000000..6b9f742\n--- /dev/null\n+++ b/test_digest_edge_cases.py\n@@ -0,0 +1,85 @@\n+#!/usr/bin/env python\n+import requests\n+from requests.auth import HTTPDigestAuth\n+\n+def test_digest_header_generation():\n+    \"\"\"Test various edge cases for digest auth header generation.\"\"\"\n+    \n+    print(\"=== Testing Digest Auth Header Generation ===\")\n+    \n+    # Test 1: Basic case with qop='auth'\n+    print(\"\\n1. Testing with qop='auth':\")\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'testrealm@host.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+    }\n+    header = auth.build_digest_header('GET', 'http://example.com/path')\n+    print(f\"Header: {header}\")\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted\"\n+    assert 'nc=00000001' in header, \"nc should be present\"\n+    assert 'cnonce=\"' in header, \"cnonce should be quoted\"\n+    \n+    # Test 2: Case with qop='auth,auth-int' (server offers both)\n+    print(\"\\n2. Testing with qop='auth,auth-int':\")\n+    auth.chal['qop'] = 'auth,auth-int'\n+    header = auth.build_digest_header('GET', 'http://example.com/path')\n+    print(f\"Header: {header}\")\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted and should be 'auth'\"\n+    assert 'nc=00000002' in header, \"nc should increment\"\n+    \n+    # Test 3: Case without qop (RFC 2069 compatibility)\n+    print(\"\\n3. Testing without qop (RFC 2069):\")\n+    auth.chal.pop('qop', None)\n+    header = auth.build_digest_header('GET', 'http://example.com/path')\n+    print(f\"Header: {header}\")\n+    assert 'qop=' not in header, \"qop should not be present\"\n+    assert 'nc=' not in header, \"nc should not be present\"\n+    assert 'cnonce=' not in header, \"cnonce should not be present\"\n+    \n+    # Test 4: Case with algorithm specified\n+    print(\"\\n4. Testing with algorithm='MD5':\")\n+    auth.chal['qop'] = 'auth'\n+    auth.chal['algorithm'] = 'MD5'\n+    header = auth.build_digest_header('GET', 'http://example.com/path')\n+    print(f\"Header: {header}\")\n+    assert 'algorithm=\"MD5\"' in header, \"algorithm should be quoted\"\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted\"\n+    \n+    # Test 5: Case with algorithm='MD5-sess'\n+    print(\"\\n5. Testing with algorithm='MD5-sess':\")\n+    auth.chal['algorithm'] = 'MD5-sess'\n+    header = auth.build_digest_header('GET', 'http://example.com/path')\n+    print(f\"Header: {header}\")\n+    assert 'algorithm=\"MD5-sess\"' in header, \"algorithm should be quoted\"\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted\"\n+    \n+    # Test 6: Verify all quoted parameters\n+    print(\"\\n6. Verifying all parameters are properly quoted:\")\n+    auth.chal = {\n+        'realm': 'testrealm@host.com',\n+        'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+        'qop': 'auth',\n+        'opaque': '5ccc069c403ebaf9f0171e9517f40e41',\n+        'algorithm': 'MD5'\n+    }\n+    header = auth.build_digest_header('GET', 'http://example.com/path?query=value')\n+    print(f\"Header: {header}\")\n+    \n+    # Check all quoted parameters\n+    assert 'username=\"user\"' in header\n+    assert 'realm=\"testrealm@host.com\"' in header\n+    assert 'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in header\n+    assert 'uri=\"/path?query=value\"' in header\n+    assert 'response=\"' in header  # response is always quoted\n+    assert 'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in header\n+    assert 'algorithm=\"MD5\"' in header\n+    assert 'qop=\"auth\"' in header\n+    assert 'cnonce=\"' in header\n+    \n+    print(\"\\n\u2713 All tests passed!\")\n+    \n+if __name__ == '__main__':\n+    test_digest_header_generation()\n\\ No newline at end of file\ndiff --git a/test_digest_qop.py b/test_digest_qop.py\nnew file mode 100644\nindex 0000000..efc9b39\n--- /dev/null\n+++ b/test_digest_qop.py\n@@ -0,0 +1,34 @@\n+#!/usr/bin/env python\n+import requests\n+from requests.auth import HTTPDigestAuth\n+\n+# Create a mock server response to test digest auth\n+class MockResponse:\n+    def __init__(self):\n+        self.headers = {\n+            'www-authenticate': 'Digest realm=\"testrealm@host.com\", qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n+        }\n+        self.status_code = 401\n+        self.request = type('Request', (), {'method': 'GET', 'url': 'http://example.com/'})()\n+        self.connection = type('Connection', (), {'send': lambda x, **kwargs: None})()\n+\n+# Test the digest auth header generation\n+auth = HTTPDigestAuth('user', 'pass')\n+\n+# Simulate receiving a 401 challenge\n+response = MockResponse()\n+auth.handle_401(response)\n+\n+# Now check what header would be generated\n+header = auth.build_digest_header('GET', 'http://example.com/')\n+print(\"Generated Digest header:\")\n+print(header)\n+print()\n+\n+# Check if qop is quoted\n+if 'qop=\"auth\"' in header:\n+    print(\"\u2713 qop is properly quoted\")\n+elif 'qop=auth' in header:\n+    print(\"\u2717 qop is NOT quoted (should be qop=\\\\\\\"auth\\\\\\\")\")\n+else:\n+    print(\"? qop not found in header\")\n\\ No newline at end of file\ndiff --git a/test_qop_issue.py b/test_qop_issue.py\nnew file mode 100644\nindex 0000000..63cb87e\n--- /dev/null\n+++ b/test_qop_issue.py\n@@ -0,0 +1,43 @@\n+#!/usr/bin/env python\n+import requests\n+from requests.auth import HTTPDigestAuth\n+\n+# Let's directly test the build_digest_header method\n+auth = HTTPDigestAuth('user', 'pass')\n+\n+# Set up a mock challenge\n+auth.chal = {\n+    'realm': 'testrealm@host.com',\n+    'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+    'qop': 'auth',\n+    'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+}\n+\n+# Generate the digest header\n+header = auth.build_digest_header('GET', 'http://example.com/')\n+print(\"Generated Digest header:\")\n+print(header)\n+print()\n+\n+# Check if qop is quoted\n+if 'qop=\"auth\"' in header:\n+    print(\"\u2713 qop is properly quoted\")\n+elif 'qop=auth' in header:\n+    print(\"\u2717 qop is NOT quoted (should be qop=\\\"auth\\\")\")\n+else:\n+    print(\"? qop not found in header\")\n+\n+# Also test with qop containing multiple values\n+print(\"\\n--- Testing with qop='auth,auth-int' ---\")\n+auth.chal['qop'] = 'auth,auth-int'\n+header2 = auth.build_digest_header('GET', 'http://example.com/')\n+print(\"Generated Digest header:\")\n+print(header2)\n+print()\n+\n+# Check RFC compliance\n+print(\"\\n--- RFC 2617 Compliance Check ---\")\n+print(\"According to RFC 2617, qop-options should be a quoted string.\")\n+print(\"The server sends: qop=\\\"auth,auth-int\\\" (quoted)\")\n+print(\"The client should send: qop=\\\"auth\\\" (quoted)\")\n+print(\"Current implementation sends: qop=auth (unquoted)\")\n\\ No newline at end of file\ndiff --git a/test_qop_with_spaces.py b/test_qop_with_spaces.py\nnew file mode 100644\nindex 0000000..4c57d98\n--- /dev/null\n+++ b/test_qop_with_spaces.py\n@@ -0,0 +1,25 @@\n+#!/usr/bin/env python\n+import requests\n+from requests.auth import HTTPDigestAuth\n+\n+# Test with qop that might have spaces (though RFC says it shouldn't)\n+auth = HTTPDigestAuth('user', 'pass')\n+auth.chal = {\n+    'realm': 'testrealm@host.com',\n+    'nonce': 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n+    'qop': 'auth, auth-int',  # Note: space after comma\n+    'opaque': '5ccc069c403ebaf9f0171e9517f40e41'\n+}\n+\n+header = auth.build_digest_header('GET', 'http://example.com/')\n+print('Generated header:')\n+print(header)\n+print()\n+print('Checking for qop=\\\\\\\"auth\\\\\\\":', 'qop=\\\"auth\\\"' in header)\n+\n+# Also test with just 'auth' but with spaces\n+auth.chal['qop'] = 'auth '\n+header2 = auth.build_digest_header('GET', 'http://example.com/')\n+print('\\nWith qop=\\\"auth \\\":')\n+print(header2)\n+print('Checking for qop=\\\\\\\"auth\\\\\\\":', 'qop=\\\"auth\\\"' in header2)\n\\ No newline at end of file\ndiff --git a/test_rfc_compliance.py b/test_rfc_compliance.py\nnew file mode 100644\nindex 0000000..78bd7fd\n--- /dev/null\n+++ b/test_rfc_compliance.py\n@@ -0,0 +1,101 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test RFC 2617 compliance for Digest Auth qop quoting.\n+\n+According to RFC 2617 section 3.2.2:\n+  qop\n+    This directive is optional, but if present it affects the\n+    computation of the request-digest.  It is a quoted string\n+    containing one of the values the server sent in the qop-options\n+    of the WWW-Authenticate response header.\n+    \n+The server sends qop-options as a quoted string (e.g., qop=\"auth,auth-int\")\n+and the client must send qop as a quoted string (e.g., qop=\"auth\").\n+\"\"\"\n+import re\n+from requests.auth import HTTPDigestAuth\n+\n+def parse_digest_header(header):\n+    \"\"\"Parse a Digest header into a dictionary.\"\"\"\n+    if not header.startswith('Digest '):\n+        return {}\n+    \n+    # Remove 'Digest ' prefix\n+    header = header[7:]\n+    \n+    # Parse key=value pairs\n+    pattern = r'(\\w+)=(\"([^\"]+)\"|([^\",]+))'\n+    matches = re.findall(pattern, header)\n+    \n+    result = {}\n+    for match in matches:\n+        key = match[0]\n+        # Use quoted value if available, otherwise unquoted\n+        value = match[2] if match[2] else match[3]\n+        result[key] = value\n+    \n+    return result\n+\n+def test_rfc_compliance():\n+    print(\"=== RFC 2617 Compliance Test ===\")\n+    print()\n+    \n+    # Test 1: Server sends qop=\"auth\"\n+    print(\"Test 1: Server sends qop=\\\"auth\\\"\")\n+    auth = HTTPDigestAuth('user', 'pass')\n+    auth.chal = {\n+        'realm': 'test',\n+        'nonce': '123456',\n+        'qop': 'auth',\n+        'opaque': 'opaque123'\n+    }\n+    \n+    header = auth.build_digest_header('GET', 'http://example.com/')\n+    parsed = parse_digest_header(header)\n+    \n+    print(f\"  Generated header: {header}\")\n+    print(f\"  Parsed qop value: {parsed.get('qop', 'NOT FOUND')}\")\n+    is_quoted = 'qop=\"auth\"' in header\n+    print(f\"  Is qop quoted in header? {is_quoted}\")\n+    assert parsed.get('qop') == 'auth', f\"Expected qop='auth', got {parsed.get('qop')}\"\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted\"\n+    print(\"  \u2713 PASS\")\n+    print()\n+    \n+    # Test 2: Server sends qop=\"auth,auth-int\"\n+    print('Test 2: Server sends qop=\"auth,auth-int\"')\n+    auth.chal['qop'] = 'auth,auth-int'\n+    header = auth.build_digest_header('GET', 'http://example.com/')\n+    parsed = parse_digest_header(header)\n+    \n+    print(f\"  Generated header: {header}\")\n+    print(f\"  Parsed qop value: {parsed.get('qop', 'NOT FOUND')}\")\n+    is_quoted = 'qop=\"auth\"' in header\n+    print(f\"  Is qop quoted in header? {is_quoted}\")\n+    assert parsed.get('qop') == 'auth', f\"Expected qop='auth', got {parsed.get('qop')}\"\n+    assert 'qop=\"auth\"' in header, \"qop should be quoted\"\n+    print(\"  \u2713 PASS\")\n+    print()\n+    \n+    # Test 3: Compare with other quoted values\n+    print(\"Test 3: All string values should be quoted\")\n+    auth.chal['algorithm'] = 'MD5'\n+    header = auth.build_digest_header('GET', 'http://example.com/')\n+    \n+    # Check that all string parameters are quoted\n+    string_params = ['username', 'realm', 'nonce', 'uri', 'response', 'opaque', 'algorithm', 'qop', 'cnonce']\n+    for param in string_params:\n+        if param in header:\n+            # Check if parameter is followed by =\"value\"\n+            pattern = f'{param}=\"[^\"]+\"'\n+            if not re.search(pattern, header):\n+                print(f\"  \u2717 {param} is not properly quoted\")\n+            else:\n+                print(f\"  \u2713 {param} is properly quoted\")\n+    \n+    print()\n+    print(\"=== All tests passed! ===\")\n+    print(\"The implementation is now RFC 2617 compliant for qop quoting.\")\n+\n+if __name__ == '__main__':\n+    test_rfc_compliance()\n\\ No newline at end of file\n"}