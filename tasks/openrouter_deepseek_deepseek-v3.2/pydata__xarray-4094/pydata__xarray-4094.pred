{"model_name_or_path": "openrouter_deepseek_deepseek-v3.2", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/analyze_issue.py b/analyze_issue.py\nnew file mode 100644\nindex 00000000..95fcd289\n--- /dev/null\n+++ b/analyze_issue.py\n@@ -0,0 +1,62 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test 1: Original failing case\n+print(\"Test 1: Original failing case\")\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+print(f\"Stacked shape: {stacked.shape}\")\n+print(f\"Stacked dims: {stacked.dims}\")\n+print(f\"Stacked coords: {list(stacked.coords.keys())}\")\n+print(f\"Stacked indexes: {stacked.indexes}\")\n+\n+# Let's look at the MultiIndex\n+idx = stacked.indexes['y']\n+print(f\"\\nMultiIndex levels: {idx.levels}\")\n+print(f\"MultiIndex names: {idx.names}\")\n+print(f\"MultiIndex codes: {idx.codes}\")\n+\n+# Test 2: Multi-dimensional case that works\n+print(\"\\n\\nTest 2: Multi-dimensional case that works\")\n+arr1 = xr.DataArray(\n+    np.arange(6).reshape(2, 3),\n+    coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])],\n+)\n+arr2 = xr.DataArray(\n+    np.arange(2),\n+    coords=[(\"x\", [0, 1])],\n+)\n+data2 = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+stacked2 = data2.to_stacked_array('z', sample_dims=['x'])\n+print(f\"Stacked2 shape: {stacked2.shape}\")\n+print(f\"Stacked2 dims: {stacked2.dims}\")\n+print(f\"Stacked2 coords: {list(stacked2.coords.keys())}\")\n+\n+idx2 = stacked2.indexes['z']\n+print(f\"\\nMultiIndex levels: {idx2.levels}\")\n+print(f\"MultiIndex names: {idx2.names}\")\n+print(f\"MultiIndex codes: {idx2.codes}\")\n+\n+# The key difference is that in Test 1, after selection we get a scalar 'y' coordinate\n+# In Test 2, after selection we don't have a 'z' coordinate at all\n+\n+# Let's check what happens in to_stacked_array for single-dim variables\n+print(\"\\n\\nChecking to_stacked_array implementation...\")\n+# When we have single-dim variables, the stacking_dims is empty tuple\n+stacking_dims = tuple(dim for dim in data.dims if dim not in ['x'])\n+print(f\"Stacking dims for Test 1: {stacking_dims}\")\n+\n+# In ensure_stackable function, for a variable with dims=['x']:\n+# - stacking_dims = () (empty tuple)\n+# - assign_coords = {variable_dim: 'a', **{dim: None for dim in stacking_dims if dim not in val.dims}}\n+#   Since stacking_dims is empty, assign_coords = {variable_dim: 'a'}\n+# - expand_dims = set(stacking_dims).difference(set(val.dims)) = set().difference({'x'}) = set()\n+# - expand_dims.add(variable_dim) = {'variable'}\n+# - So we expand_dims(['variable']) and stack({new_dim: ('variable',)})\n+\n+# This creates a MultiIndex with just one level (variable)\n+# When we select with variable_dim='a', we get a DataArray with scalar coordinate 'y'\n\\ No newline at end of file\ndiff --git a/debug_error.py b/debug_error.py\nnew file mode 100644\nindex 00000000..cf1a324b\n--- /dev/null\n+++ b/debug_error.py\n@@ -0,0 +1,49 @@\n+import numpy as np\n+import xarray as xr\n+import pandas as pd\n+\n+# Reproduce the error from the PR description\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+print(\"Original dataset:\")\n+print(data)\n+print(\"\\nStacking...\")\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+print(\"Stacked array:\")\n+print(stacked)\n+print(\"\\nStacked array indexes:\")\n+print(f\"Indexes: {stacked.indexes}\")\n+print(f\"Index 'y': {stacked.indexes['y']}\")\n+print(f\"Index 'y' type: {type(stacked.indexes['y'])}\")\n+print(f\"Index 'y' levels: {stacked.indexes['y'].levels}\")\n+print(f\"Index 'y' names: {stacked.indexes['y'].names}\")\n+\n+print(\"\\nTrying to unstack...\")\n+try:\n+    # Let's trace through the to_unstacked_dataset method\n+    idx = stacked.indexes['y']\n+    print(f\"\\nIndex is MultiIndex: {isinstance(idx, pd.MultiIndex)}\")\n+    level_number = idx._get_level_number(0)\n+    print(f\"Level number: {level_number}\")\n+    variables = idx.levels[level_number]\n+    print(f\"Variables: {variables}\")\n+    variable_dim = idx.names[level_number]\n+    print(f\"Variable dim: {variable_dim}\")\n+    \n+    # Let's see what happens when we select\n+    for k in variables:\n+        print(f\"\\nSelecting variable_dim={k}:\")\n+        selected = stacked.sel({variable_dim: k})\n+        print(f\"Selected shape: {selected.shape}\")\n+        print(f\"Selected dims: {selected.dims}\")\n+        squeezed = selected.squeeze(drop=True)\n+        print(f\"After squeeze shape: {squeezed.shape}\")\n+        print(f\"After squeeze dims: {squeezed.dims}\")\n+        \n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n\\ No newline at end of file\ndiff --git a/debug_error2.py b/debug_error2.py\nnew file mode 100644\nindex 00000000..2f63a757\n--- /dev/null\n+++ b/debug_error2.py\n@@ -0,0 +1,52 @@\n+import numpy as np\n+import xarray as xr\n+import pandas as pd\n+\n+# Reproduce the error from the PR description\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+print(\"Original dataset:\")\n+print(data)\n+print(\"\\nStacking...\")\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+print(\"Stacked array:\")\n+print(stacked)\n+\n+print(\"\\nTrying to unstack manually...\")\n+# Let's manually do what to_unstacked_dataset does\n+idx = stacked.indexes['y']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+# pull variables out of datarray\n+data_dict = {}\n+for k in variables:\n+    data_dict[k] = stacked.sel({variable_dim: k}).squeeze(drop=True)\n+    print(f\"\\nVariable {k}:\")\n+    print(f\"  DataArray: {data_dict[k]}\")\n+    print(f\"  dims: {data_dict[k].dims}\")\n+    print(f\"  coords: {data_dict[k].coords}\")\n+\n+print(\"\\nTrying to create Dataset from data_dict...\")\n+try:\n+    result = xr.Dataset(data_dict)\n+    print(\"Success!\")\n+    print(result)\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+    \n+print(\"\\n\\nLet's check what happens when we create Dataset with merge='override'\")\n+try:\n+    result = xr.Dataset(data_dict, compat='override')\n+    print(\"Success with compat='override'!\")\n+    print(result)\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n\\ No newline at end of file\ndiff --git a/debug_error3.py b/debug_error3.py\nnew file mode 100644\nindex 00000000..a29e2f4d\n--- /dev/null\n+++ b/debug_error3.py\n@@ -0,0 +1,62 @@\n+import numpy as np\n+import xarray as xr\n+import pandas as pd\n+\n+# Reproduce the error from the PR description\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+print(\"Original dataset:\")\n+print(data)\n+print(\"\\nStacking...\")\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+print(\"Stacked array:\")\n+print(stacked)\n+\n+print(\"\\nLet's trace through what happens...\")\n+# When we select with variable_dim, we get a scalar coordinate 'y'\n+idx = stacked.indexes['y']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+print(f\"\\nVariable dim: {variable_dim}\")\n+print(f\"Variables: {variables}\")\n+\n+for k in variables:\n+    selected = stacked.sel({variable_dim: k})\n+    print(f\"\\nSelected {k}:\")\n+    print(f\"  Shape: {selected.shape}\")\n+    print(f\"  Dims: {selected.dims}\")\n+    print(f\"  Coords: {selected.coords}\")\n+    print(f\"  Has 'y' coord: {'y' in selected.coords}\")\n+    if 'y' in selected.coords:\n+        print(f\"  y coord value: {selected.coords['y'].values}\")\n+    \n+    squeezed = selected.squeeze(drop=True)\n+    print(f\"\\nAfter squeeze:\")\n+    print(f\"  Shape: {squeezed.shape}\")\n+    print(f\"  Dims: {squeezed.dims}\")\n+    print(f\"  Coords: {squeezed.coords}\")\n+    print(f\"  Has 'y' coord: {'y' in squeezed.coords}\")\n+    if 'y' in squeezed.coords:\n+        print(f\"  y coord value: {squeezed.coords['y'].values}\")\n+\n+print(\"\\n\\nLet's try dropping the 'y' coordinate before creating the dataset:\")\n+data_dict = {}\n+for k in variables:\n+    data_dict[k] = stacked.sel({variable_dim: k}).squeeze(drop=True).drop_vars('y')\n+    print(f\"\\nVariable {k} after dropping 'y':\")\n+    print(f\"  Coords: {data_dict[k].coords}\")\n+\n+print(\"\\nTrying to create Dataset from data_dict with 'y' dropped...\")\n+try:\n+    result = xr.Dataset(data_dict)\n+    print(\"Success!\")\n+    print(result)\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n\\ No newline at end of file\ndiff --git a/debug_sel_issue.py b/debug_sel_issue.py\nnew file mode 100644\nindex 00000000..56a7f1fe\n--- /dev/null\n+++ b/debug_sel_issue.py\n@@ -0,0 +1,58 @@\n+import numpy as np\n+import xarray as xr\n+import pandas as pd\n+\n+print(\"Debugging the selection issue...\")\n+\n+# Create a simple test case\n+arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+\n+print(\"Stacked array:\")\n+print(stacked)\n+print(f\"\\nStacked indexes['y']: {stacked.indexes['y']}\")\n+\n+# When we select with variable_dim='a', what happens?\n+idx = stacked.indexes['y']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+print(f\"\\nVariable dim: {variable_dim}\")\n+print(f\"Variables: {variables}\")\n+\n+# Let's manually select 'a'\n+print(\"\\nManually selecting 'a':\")\n+selected_a = stacked.sel({variable_dim: 'a'})\n+print(f\"Selected shape: {selected_a.shape}\")\n+print(f\"Selected dims: {selected_a.dims}\")\n+print(f\"Selected coords: {selected_a.coords}\")\n+\n+# The issue is that after selection, we still have dimension 'y' \n+# but it's now a scalar coordinate with value ('a',)\n+print(f\"\\n'y' in selected_a.coords: {'y' in selected_a.coords}\")\n+if 'y' in selected_a.coords:\n+    print(f\"y coord value: {selected_a.coords['y'].values}\")\n+    print(f\"y coord shape: {selected_a.coords['y'].shape}\")\n+    print(f\"y coord dims: {selected_a.coords['y'].dims}\")\n+\n+# After squeeze\n+squeezed_a = selected_a.squeeze(drop=True)\n+print(f\"\\nAfter squeeze:\")\n+print(f\"Shape: {squeezed_a.shape}\")\n+print(f\"Dims: {squeezed_a.dims}\")\n+print(f\"Coords: {squeezed_a.coords}\")\n+print(f\"'y' in squeezed_a.coords: {'y' in squeezed_a.coords}\")\n+if 'y' in squeezed_a.coords:\n+    print(f\"y coord value: {squeezed_a.coords['y'].values}\")\n+    print(f\"y coord shape: {squeezed_a.coords['y'].shape}\")\n+    print(f\"y coord dims: {squeezed_a.coords['y'].dims}\")\n+\n+# Now let's see what happens with our fix\n+print(\"\\n\\nWith our fix (dropping 'y' coordinate):\")\n+if 'y' in squeezed_a.coords and 'y' not in squeezed_a.dims:\n+    fixed_a = squeezed_a.drop_vars('y')\n+    print(f\"After dropping 'y':\")\n+    print(f\"Coords: {fixed_a.coords}\")\n+    print(f\"'y' in coords: {'y' in fixed_a.coords}\")\n\\ No newline at end of file\ndiff --git a/debug_test5.py b/debug_test5.py\nnew file mode 100644\nindex 00000000..c8902ead\n--- /dev/null\n+++ b/debug_test5.py\n@@ -0,0 +1,48 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Debugging Test 5: Variables with 3 dimensions\")\n+arr5 = xr.DataArray(np.arange(24).reshape(2, 3, 4), \n+                   coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2]), (\"z\", [0, 1, 2, 3])])\n+data5 = xr.Dataset({\"a\": arr5, \"b\": arr5.isel(z=0)})\n+print(\"Original dataset:\")\n+print(data5)\n+\n+stacked5 = data5.to_stacked_array('w', sample_dims=['x'])\n+print(\"\\nStacked array:\")\n+print(stacked5)\n+print(f\"\\nStacked indexes['w']: {stacked5.indexes['w']}\")\n+print(f\"Stacked indexes['w'] levels: {stacked5.indexes['w'].levels}\")\n+print(f\"Stacked indexes['w'] names: {stacked5.indexes['w'].names}\")\n+\n+unstacked5 = stacked5.to_unstacked_dataset('w')\n+print(\"\\nUnstacked dataset:\")\n+print(unstacked5)\n+\n+print(\"\\n\\nChecking if they're identical...\")\n+print(f\"Are they identical? {data5.identical(unstacked5)}\")\n+\n+# Let's check what's different\n+print(\"\\nChecking differences...\")\n+print(\"Original 'a' shape:\", data5['a'].shape)\n+print(\"Unstacked 'a' shape:\", unstacked5['a'].shape)\n+print(\"Original 'b' shape:\", data5['b'].shape)\n+print(\"Unstacked 'b' shape:\", unstacked5['b'].shape)\n+\n+print(\"\\nOriginal 'a' dtype:\", data5['a'].dtype)\n+print(\"Unstacked 'a' dtype:\", unstacked5['a'].dtype)\n+print(\"Original 'b' dtype:\", data5['b'].dtype)\n+print(\"Unstacked 'b' dtype:\", unstacked5['b'].dtype)\n+\n+# Check if values are the same\n+print(\"\\nAre 'a' values equal?\", np.allclose(data5['a'].values, unstacked5['a'].values))\n+print(\"Are 'b' values equal?\", np.allclose(data5['b'].values, unstacked5['b'].values))\n+\n+# Check coordinates\n+print(\"\\nOriginal coordinates:\", list(data5.coords.keys()))\n+print(\"Unstacked coordinates:\", list(unstacked5.coords.keys()))\n+\n+# Check if 'z' coordinate has NaN values\n+print(\"\\nOriginal 'z' coordinate:\", data5.coords['z'].values)\n+print(\"Unstacked 'z' coordinate:\", unstacked5.coords['z'].values)\n+print(\"Does unstacked 'z' have NaN?\", np.any(np.isnan(unstacked5.coords['z'].values)))\n\\ No newline at end of file\ndiff --git a/debug_test5_detailed.py b/debug_test5_detailed.py\nnew file mode 100644\nindex 00000000..fb2c8cc1\n--- /dev/null\n+++ b/debug_test5_detailed.py\n@@ -0,0 +1,57 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Debugging Test 5: Variables with 3 dimensions\")\n+arr5 = xr.DataArray(np.arange(24).reshape(2, 3, 4), \n+                   coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2]), (\"z\", [0, 1, 2, 3])])\n+data5 = xr.Dataset({\"a\": arr5, \"b\": arr5.isel(z=0)})\n+print(\"Original dataset:\")\n+print(data5)\n+\n+stacked5 = data5.to_stacked_array('w', sample_dims=['x'])\n+print(\"\\nStacked array:\")\n+print(stacked5)\n+\n+# Let's trace through what to_unstacked_dataset does\n+print(\"\\n\\nTracing through to_unstacked_dataset...\")\n+idx = stacked5.indexes['w']\n+print(f\"MultiIndex levels: {idx.levels}\")\n+print(f\"MultiIndex names: {idx.names}\")\n+\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+print(f\"\\nVariable dim: {variable_dim}\")\n+print(f\"Variables: {variables}\")\n+\n+# Check what happens when we select\n+for k in variables:\n+    selected = stacked5.sel({variable_dim: k})\n+    print(f\"\\nSelected {k}:\")\n+    print(f\"  Shape: {selected.shape}\")\n+    print(f\"  Dims: {selected.dims}\")\n+    print(f\"  Coords: {list(selected.coords.keys())}\")\n+    \n+    squeezed = selected.squeeze(drop=True)\n+    print(f\"  After squeeze shape: {squeezed.shape}\")\n+    print(f\"  After squeeze dims: {squeezed.dims}\")\n+    print(f\"  After squeeze coords: {list(squeezed.coords.keys())}\")\n+    \n+    # Check if 'w' is in coords\n+    if 'w' in squeezed.coords:\n+        print(f\"  'w' in coords: True\")\n+        print(f\"  'w' shape: {squeezed.coords['w'].shape}\")\n+    else:\n+        print(f\"  'w' in coords: False\")\n+\n+# Now let's see what the actual unstacked dataset looks like\n+print(\"\\n\\nActual unstacked dataset:\")\n+unstacked5 = stacked5.to_unstacked_dataset('w')\n+print(unstacked5)\n+\n+# The issue seems to be that we're not getting the right shape back\n+# Let me check the test that's in the actual test suite\n+print(\"\\n\\nLooking at the actual test in test_dataset.py...\")\n+# The test uses create_test_stacked_array which creates 2D arrays\n+# Let me check if the issue is with 3D arrays specifically\n\\ No newline at end of file\ndiff --git a/debug_working_case.py b/debug_working_case.py\nnew file mode 100644\nindex 00000000..0ed95e35\n--- /dev/null\n+++ b/debug_working_case.py\n@@ -0,0 +1,58 @@\n+import numpy as np\n+import xarray as xr\n+import pandas as pd\n+\n+# Let's look at the working case from the tests\n+print(\"Working case from tests:\")\n+# This is similar to create_test_stacked_array\n+x = xr.DataArray(pd.Index(np.r_[:10], name=\"x\"))\n+y = xr.DataArray(pd.Index(np.r_[:20], name=\"y\"))\n+a = x * y\n+b = x * y * y\n+D = xr.Dataset({\"a\": a, \"b\": b})\n+print(\"Original dataset:\")\n+print(D)\n+\n+sample_dims = [\"x\"]\n+stacked = D.to_stacked_array(\"features\", sample_dims)\n+print(\"\\nStacked array:\")\n+print(stacked)\n+\n+unstacked = stacked.to_unstacked_dataset(\"features\")\n+print(\"\\nUnstacked dataset:\")\n+print(unstacked)\n+\n+print(f\"\\nAre they identical? {D.identical(unstacked)}\")\n+\n+# Now let's trace through what happens\n+print(\"\\n\\nTracing through to_unstacked_dataset...\")\n+idx = stacked.indexes['features']\n+print(f\"MultiIndex levels: {idx.levels}\")\n+print(f\"MultiIndex names: {idx.names}\")\n+\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+print(f\"\\nVariable dim: {variable_dim}\")\n+print(f\"Variables: {variables}\")\n+\n+# Check what happens when we select\n+for k in variables:\n+    selected = stacked.sel({variable_dim: k})\n+    print(f\"\\nSelected {k}:\")\n+    print(f\"  Shape: {selected.shape}\")\n+    print(f\"  Dims: {selected.dims}\")\n+    print(f\"  Coords: {list(selected.coords.keys())}\")\n+    \n+    squeezed = selected.squeeze(drop=True)\n+    print(f\"  After squeeze shape: {squeezed.shape}\")\n+    print(f\"  After squeeze dims: {squeezed.dims}\")\n+    print(f\"  After squeeze coords: {list(squeezed.coords.keys())}\")\n+    \n+    # Check if 'features' is in coords\n+    if 'features' in squeezed.coords:\n+        print(f\"  'features' in coords: True\")\n+        print(f\"  'features' shape: {squeezed.coords['features'].shape}\")\n+    else:\n+        print(f\"  'features' in coords: False\")\n\\ No newline at end of file\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 00000000..3557fce6\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,22 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Reproduce the error from the PR description\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+print(\"Original dataset:\")\n+print(data)\n+print(\"\\nStacking...\")\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+print(\"Stacked array:\")\n+print(stacked)\n+print(\"\\nUnstacking...\")\n+try:\n+    unstacked = stacked.to_unstacked_dataset('y')\n+    print(\"Unstacked dataset:\")\n+    print(unstacked)\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n\\ No newline at end of file\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 00000000..8cd8e8b4\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,70 @@\n+import numpy as np\n+import xarray as xr\n+\n+print(\"Testing comprehensive edge cases for to_unstacked_dataset fix\\n\")\n+\n+# Test 1: Original failing case - single-dim variables\n+print(\"Test 1: Single-dim variables\")\n+arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+unstacked = stacked.to_unstacked_dataset('y')\n+print(f\"  Original and unstacked identical? {data.identical(unstacked)}\")\n+\n+# Test 2: Multi-dim variables with different dimensions\n+print(\"\\nTest 2: Multi-dim variables with different dimensions\")\n+arr1 = xr.DataArray(np.arange(6).reshape(2, 3), coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])])\n+arr2 = xr.DataArray(np.arange(2), coords=[(\"x\", [0, 1])])\n+data2 = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+stacked2 = data2.to_stacked_array('z', sample_dims=['x'])\n+unstacked2 = stacked2.to_unstacked_dataset('z')\n+print(f\"  Original and unstacked identical? {data2.identical(unstacked2)}\")\n+\n+# Test 3: All variables have same multi-dimensions\n+print(\"\\nTest 3: All variables have same multi-dimensions\")\n+arr3 = xr.DataArray(np.arange(6).reshape(2, 3), coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])])\n+data3 = xr.Dataset({\"a\": arr3, \"b\": arr3 * 2})\n+stacked3 = data3.to_stacked_array('z', sample_dims=['x'])\n+unstacked3 = stacked3.to_unstacked_dataset('z')\n+print(f\"  Original and unstacked identical? {data3.identical(unstacked3)}\")\n+\n+# Test 4: Three variables with single dimension\n+print(\"\\nTest 4: Three variables with single dimension\")\n+arr4 = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+data4 = xr.Dataset({\"a\": arr4, \"b\": arr4 * 2, \"c\": arr4 * 3})\n+stacked4 = data4.to_stacked_array('y', sample_dims=['x'])\n+unstacked4 = stacked4.to_unstacked_dataset('y')\n+print(f\"  Original and unstacked identical? {data4.identical(unstacked4)}\")\n+\n+# Test 5: Variables with 3 dimensions\n+print(\"\\nTest 5: Variables with 3 dimensions\")\n+arr5 = xr.DataArray(np.arange(24).reshape(2, 3, 4), \n+                   coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2]), (\"z\", [0, 1, 2, 3])])\n+data5 = xr.Dataset({\"a\": arr5, \"b\": arr5.isel(z=0)})\n+stacked5 = data5.to_stacked_array('w', sample_dims=['x'])\n+unstacked5 = stacked5.to_unstacked_dataset('w')\n+print(f\"  Original and unstacked identical? {data5.identical(unstacked5)}\")\n+\n+# Test 6: Using different level\n+print(\"\\nTest 6: Using different level (should raise error for single-level MultiIndex)\")\n+try:\n+    # For single-level MultiIndex, level 0 is the only valid level\n+    stacked.to_unstacked_dataset('y', level=0)\n+    print(\"  Level 0 works (as expected)\")\n+except Exception as e:\n+    print(f\"  Error with level 0: {e}\")\n+\n+# Test 7: Check that we don't drop coordinates that should be kept\n+print(\"\\nTest 7: Verify we don't drop dimension coordinates\")\n+# Create a dataset with additional coordinates\n+arr7 = xr.DataArray(np.arange(6).reshape(2, 3), \n+                   coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])])\n+# Add extra coordinate after creating the array\n+arr7 = arr7.assign_coords(extra=(\"x\", [10, 20]))\n+data7 = xr.Dataset({\"a\": arr7, \"b\": arr7.isel(y=0)})\n+stacked7 = data7.to_stacked_array('z', sample_dims=['x'])\n+unstacked7 = stacked7.to_unstacked_dataset('z')\n+print(f\"  Original and unstacked identical? {data7.identical(unstacked7)}\")\n+print(f\"  'extra' coordinate preserved? {'extra' in unstacked7.coords}\")\n+\n+print(\"\\nAll tests completed!\")\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 00000000..81775ce7\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,63 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test edge case: what if 'y' is already a dimension in the original data?\n+print(\"Test 1: 'y' is already a dimension\")\n+arr = xr.DataArray(\n+     np.arange(6).reshape(2, 3),\n+     coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+print(\"Original dataset:\")\n+print(data)\n+\n+# If we stack with sample_dims=['x'], then 'y' is a stacking dimension\n+stacked = data.to_stacked_array('z', sample_dims=['x'])\n+print(\"\\nStacked array:\")\n+print(stacked)\n+print(f\"\\nStacked indexes['z']: {stacked.indexes['z']}\")\n+\n+# Now when we unstack, we should get 'y' back as a dimension\n+idx = stacked.indexes['z']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+data_dict = {}\n+for k in variables:\n+    selected = stacked.sel({variable_dim: k}).squeeze(drop=True)\n+    print(f\"\\nSelected {k}:\")\n+    print(f\"  dims: {selected.dims}\")\n+    print(f\"  coords: {list(selected.coords.keys())}\")\n+    if 'z' in selected.coords:\n+        print(f\"  'z' coord: {selected.coords['z'].values}\")\n+    if 'y' in selected.coords:\n+        print(f\"  'y' coord: {selected.coords['y'].values}\")\n+    \n+    # In this case, 'z' is not in coords after squeeze because it was a dimension\n+    # 'y' should be in coords as a dimension coordinate\n+\n+# Test 2: What if we have multiple stacking dimensions?\n+print(\"\\n\\nTest 2: Multiple stacking dimensions\")\n+arr1 = xr.DataArray(\n+    np.arange(12).reshape(2, 3, 2),\n+    coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2]), (\"z\", [0, 1])],\n+)\n+arr2 = xr.DataArray(\n+    np.arange(6).reshape(2, 3),\n+    coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])],\n+)\n+data2 = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+print(\"Original dataset:\")\n+print(data2)\n+\n+stacked2 = data2.to_stacked_array('w', sample_dims=['x'])\n+print(\"\\nStacked array:\")\n+print(stacked2)\n+\n+idx2 = stacked2.indexes['w']\n+print(f\"\\nMultiIndex levels: {idx2.levels}\")\n+print(f\"MultiIndex names: {idx2.names}\")\n+\n+# When we select variable='a', we should get back dimensions x, y, z\n+# When we select variable='b', we should get back dimensions x, y\n\\ No newline at end of file\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 00000000..2ec9bf1b\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,70 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test the fix\n+arr = xr.DataArray(\n+     np.arange(3),\n+     coords=[(\"x\", [0, 1, 2])],\n+ )\n+data = xr.Dataset({\"a\": arr, \"b\": arr})\n+stacked = data.to_stacked_array('y', sample_dims=['x'])\n+\n+# Let's manually implement the fix\n+idx = stacked.indexes['y']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+# pull variables out of datarray\n+data_dict = {}\n+for k in variables:\n+    # Select and squeeze\n+    selected = stacked.sel({variable_dim: k}).squeeze(drop=True)\n+    \n+    # Drop the stacked dimension coordinate if it exists\n+    # (it will be a scalar coordinate after squeeze)\n+    if 'y' in selected.coords:\n+        selected = selected.drop_vars('y')\n+    \n+    data_dict[k] = selected\n+\n+# unstacked dataset\n+result = xr.Dataset(data_dict)\n+print(\"Result:\")\n+print(result)\n+print(\"\\nOriginal:\")\n+print(data)\n+print(f\"\\nAre they identical? {data.identical(result)}\")\n+\n+# Also test with multi-dimensional case\n+print(\"\\n\\nTesting multi-dimensional case...\")\n+arr1 = xr.DataArray(\n+    np.arange(6).reshape(2, 3),\n+    coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])],\n+)\n+arr2 = xr.DataArray(\n+    np.arange(2),\n+    coords=[(\"x\", [0, 1])],\n+)\n+data2 = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+stacked2 = data2.to_stacked_array('z', sample_dims=['x'])\n+\n+idx2 = stacked2.indexes['z']\n+level_number2 = idx2._get_level_number(0)\n+variables2 = idx2.levels[level_number2]\n+variable_dim2 = idx2.names[level_number2]\n+\n+data_dict2 = {}\n+for k in variables2:\n+    selected = stacked2.sel({variable_dim2: k}).squeeze(drop=True)\n+    # Drop the stacked dimension coordinate if it exists\n+    if 'z' in selected.coords:\n+        selected = selected.drop_vars('z')\n+    data_dict2[k] = selected\n+\n+result2 = xr.Dataset(data_dict2)\n+print(\"Result2:\")\n+print(result2)\n+print(\"\\nOriginal2:\")\n+print(data2)\n+print(f\"\\nAre they identical? {data2.identical(result2)}\")\n\\ No newline at end of file\ndiff --git a/test_hypothesis.py b/test_hypothesis.py\nnew file mode 100644\nindex 00000000..9bda1fa9\n--- /dev/null\n+++ b/test_hypothesis.py\n@@ -0,0 +1,62 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Hypothesis: The issue only happens when the MultiIndex has only one level\n+print(\"Testing hypothesis...\")\n+\n+# Case 1: Single-dim variables -> MultiIndex with 1 level\n+arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+data1 = xr.Dataset({\"a\": arr, \"b\": arr})\n+stacked1 = data1.to_stacked_array('y', sample_dims=['x'])\n+print(f\"Case 1 - MultiIndex levels: {len(stacked1.indexes['y'].levels)}\")\n+\n+# Check if 'y' is in coords after selection\n+idx1 = stacked1.indexes['y']\n+level_number1 = idx1._get_level_number(0)\n+variables1 = idx1.levels[level_number1]\n+variable_dim1 = idx1.names[level_number1]\n+\n+for k in variables1:\n+    selected = stacked1.sel({variable_dim1: k}).squeeze(drop=True)\n+    print(f\"  Selected {k}: 'y' in coords? {'y' in selected.coords}\")\n+\n+# Case 2: Multi-dim variables -> MultiIndex with >1 level  \n+arr1 = xr.DataArray(np.arange(6).reshape(2, 3), coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])])\n+arr2 = xr.DataArray(np.arange(2), coords=[(\"x\", [0, 1])])\n+data2 = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+stacked2 = data2.to_stacked_array('z', sample_dims=['x'])\n+print(f\"\\nCase 2 - MultiIndex levels: {len(stacked2.indexes['z'].levels)}\")\n+\n+# Check if 'z' is in coords after selection\n+idx2 = stacked2.indexes['z']\n+level_number2 = idx2._get_level_number(0)\n+variables2 = idx2.levels[level_number2]\n+variable_dim2 = idx2.names[level_number2]\n+\n+for k in variables2:\n+    selected = stacked2.sel({variable_dim2: k}).squeeze(drop=True)\n+    print(f\"  Selected {k}: 'z' in coords? {'z' in selected.coords}\")\n+\n+# So the issue is: when MultiIndex has only one level, \n+# after .sel({variable_dim: k}).squeeze(drop=True), \n+# the stacked dimension becomes a scalar coordinate\n+\n+# But we should check: is this coordinate always scalar?\n+# Let's test with 2D variables but only one stacking dim\n+print(\"\\n\\nCase 3: 2D variables but only one stacking dim\")\n+arr3 = xr.DataArray(np.arange(6).reshape(2, 3), coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])])\n+data3 = xr.Dataset({\"a\": arr3, \"b\": arr3})\n+stacked3 = data3.to_stacked_array('z', sample_dims=['x'])\n+print(f\"Case 3 - MultiIndex levels: {len(stacked3.indexes['z'].levels)}\")\n+\n+idx3 = stacked3.indexes['z']\n+level_number3 = idx3._get_level_number(0)\n+variables3 = idx3.levels[level_number3]\n+variable_dim3 = idx3.names[level_number3]\n+\n+for k in variables3:\n+    selected = stacked3.sel({variable_dim3: k}).squeeze(drop=True)\n+    print(f\"  Selected {k}: 'z' in coords? {'z' in selected.coords}\")\n+    if 'z' in selected.coords:\n+        print(f\"    'z' shape: {selected.coords['z'].shape}\")\n+        print(f\"    'z' is scalar? {selected.coords['z'].shape == ()}\")\n\\ No newline at end of file\ndiff --git a/test_multi_dim.py b/test_multi_dim.py\nnew file mode 100644\nindex 00000000..1b5e770c\n--- /dev/null\n+++ b/test_multi_dim.py\n@@ -0,0 +1,56 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test with multi-dimensional variables\n+arr1 = xr.DataArray(\n+    np.arange(6).reshape(2, 3),\n+    coords=[(\"x\", [0, 1]), (\"y\", [0, 1, 2])],\n+)\n+arr2 = xr.DataArray(\n+    np.arange(2),\n+    coords=[(\"x\", [0, 1])],\n+)\n+data = xr.Dataset({\"a\": arr1, \"b\": arr2})\n+print(\"Original dataset:\")\n+print(data)\n+print(\"\\nStacking with sample_dims=['x']...\")\n+stacked = data.to_stacked_array('z', sample_dims=['x'])\n+print(\"Stacked array:\")\n+print(stacked)\n+print(\"\\nUnstacking...\")\n+try:\n+    unstacked = stacked.to_unstacked_dataset('z')\n+    print(\"Success!\")\n+    print(unstacked)\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\n\\nNow let's trace through what happens...\")\n+idx = stacked.indexes['z']\n+level_number = idx._get_level_number(0)\n+variables = idx.levels[level_number]\n+variable_dim = idx.names[level_number]\n+\n+print(f\"\\nVariable dim: {variable_dim}\")\n+print(f\"Variables: {variables}\")\n+\n+for k in variables:\n+    selected = stacked.sel({variable_dim: k})\n+    print(f\"\\nSelected {k}:\")\n+    print(f\"  Shape: {selected.shape}\")\n+    print(f\"  Dims: {selected.dims}\")\n+    print(f\"  Coords: {selected.coords}\")\n+    print(f\"  Has 'z' coord: {'z' in selected.coords}\")\n+    if 'z' in selected.coords:\n+        print(f\"  z coord value: {selected.coords['z'].values}\")\n+    \n+    squeezed = selected.squeeze(drop=True)\n+    print(f\"\\nAfter squeeze:\")\n+    print(f\"  Shape: {squeezed.shape}\")\n+    print(f\"  Dims: {squeezed.dims}\")\n+    print(f\"  Coords: {squeezed.coords}\")\n+    print(f\"  Has 'z' coord: {'z' in squeezed.coords}\")\n+    if 'z' in squeezed.coords:\n+        print(f\"  z coord value: {squeezed.coords['z'].values}\")\n\\ No newline at end of file\ndiff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..8ae2773c 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1962,6 +1962,10 @@ class DataArray(AbstractArray, DataWithCoords):\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            # Drop the stacked dimension coordinate if it exists as a scalar coordinate\n+            # This happens when the MultiIndex has only one level\n+            if dim in data_dict[k].coords and dim not in data_dict[k].dims:\n+                data_dict[k] = data_dict[k].drop_vars(dim)\n \n         # unstacked dataset\n         return Dataset(data_dict)\n"}