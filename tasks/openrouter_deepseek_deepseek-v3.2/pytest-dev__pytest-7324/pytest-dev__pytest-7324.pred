{"model_name_or_path": "openrouter_deepseek_deepseek-v3.2", "instance_id": "pytest-dev__pytest-7324", "model_patch": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 000000000..b6a9f83f6\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,23 @@\n+#!/usr/bin/env python\n+from _pytest.mark.expression import Expression\n+\n+print(\"Testing Expression.compile('False')\")\n+try:\n+    expr = Expression.compile(\"False\")\n+    print(f\"Successfully compiled: {expr}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+\n+print(\"\\nTesting Expression.compile('True')\")\n+try:\n+    expr = Expression.compile(\"True\")\n+    print(f\"Successfully compiled: {expr}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+\n+print(\"\\nTesting Expression.compile('None')\")\n+try:\n+    expr = Expression.compile(\"None\")\n+    print(f\"Successfully compiled: {expr}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n\\ No newline at end of file\ndiff --git a/reproduce_issue2.py b/reproduce_issue2.py\nnew file mode 100644\nindex 000000000..2f559724f\n--- /dev/null\n+++ b/reproduce_issue2.py\n@@ -0,0 +1,57 @@\n+#!/usr/bin/env python\n+import ast\n+import sys\n+from _pytest.mark.expression import Expression\n+\n+print(f\"Python version: {sys.version}\")\n+print(f\"Python implementation: {sys.implementation.name}\")\n+\n+# Let's trace through what happens in Expression.compile\n+input_str = \"False\"\n+print(f\"\\nProcessing input: '{input_str}'\")\n+\n+# First, let's see what the scanner produces\n+from _pytest.mark.expression import Scanner, TokenType\n+scanner = Scanner(input_str)\n+print(\"Tokens:\")\n+while True:\n+    token = scanner.current\n+    print(f\"  {token.type}: '{token.value}' at pos {token.pos}\")\n+    if token.type == TokenType.EOF:\n+        break\n+    scanner.current = next(scanner.tokens)\n+\n+# Now let's see what the AST looks like\n+print(\"\\nAST generation:\")\n+scanner = Scanner(input_str)\n+try:\n+    from _pytest.mark.expression import expression\n+    ast_expr = expression(scanner)\n+    print(f\"AST: {ast.dump(ast_expr)}\")\n+except Exception as e:\n+    print(f\"Error generating AST: {type(e).__name__}: {e}\")\n+\n+# Try to compile the AST directly\n+print(\"\\nDirect AST compilation:\")\n+try:\n+    # Create an AST for \"False\" as a Name node (what the current code does)\n+    name_node = ast.Name(\"False\", ast.Load())\n+    expr_node = ast.Expression(name_node)\n+    ast.fix_missing_locations(expr_node)\n+    print(f\"AST for Name('False'): {ast.dump(expr_node)}\")\n+    code = compile(expr_node, filename=\"<test>\", mode=\"eval\")\n+    print(f\"Compiled successfully: {code}\")\n+except Exception as e:\n+    print(f\"Error compiling Name('False'): {type(e).__name__}: {e}\")\n+\n+# Compare with Constant node\n+print(\"\\nAST with Constant node:\")\n+try:\n+    const_node = ast.Constant(False)\n+    expr_node = ast.Expression(const_node)\n+    ast.fix_missing_locations(expr_node)\n+    print(f\"AST for Constant(False): {ast.dump(expr_node)}\")\n+    code = compile(expr_node, filename=\"<test>\", mode=\"eval\")\n+    print(f\"Compiled successfully: {code}\")\n+except Exception as e:\n+    print(f\"Error compiling Constant(False): {type(e).__name__}: {e}\")\n\\ No newline at end of file\n"}