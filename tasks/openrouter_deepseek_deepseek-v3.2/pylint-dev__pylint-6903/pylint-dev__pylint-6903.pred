{"model_name_or_path": "openrouter_deepseek_deepseek-v3.2", "instance_id": "pylint-dev__pylint-6903", "model_patch": "diff --git a/debug_query_cpu.py b/debug_query_cpu.py\nnew file mode 100644\nindex 00000000..51188828\n--- /dev/null\n+++ b/debug_query_cpu.py\n@@ -0,0 +1,35 @@\n+#!/usr/bin/env python3\n+\"\"\"Debug _query_cpu function.\"\"\"\n+\n+import os\n+import sys\n+from pathlib import Path\n+\n+# Add the pylint directory to the path\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu\n+\n+# Test the actual function on the current system\n+print(\"Testing _query_cpu() on current system...\")\n+result = _query_cpu()\n+print(f\"_query_cpu() returned: {result}\")\n+\n+# Check if the files exist\n+print(\"\\nChecking if cgroup files exist:\")\n+print(f\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us exists: {Path('/sys/fs/cgroup/cpu/cpu.cfs_quota_us').is_file()}\")\n+print(f\"/sys/fs/cgroup/cpu/cpu.cfs_period_us exists: {Path('/sys/fs/cgroup/cpu/cpu.cfs_period_us').is_file()}\")\n+print(f\"/sys/fs/cgroup/cpu/cpu.shares exists: {Path('/sys/fs/cgroup/cpu/cpu.shares').is_file()}\")\n+\n+# Try to read them if they exist\n+if Path(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\").is_file():\n+    with open(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\", encoding=\"utf-8\") as f:\n+        print(f\"cpu.cfs_quota_us content: {f.read().strip()}\")\n+\n+if Path(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\").is_file():\n+    with open(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\", encoding=\"utf-8\") as f:\n+        print(f\"cpu.cfs_period_us content: {f.read().strip()}\")\n+\n+if Path(\"/sys/fs/cgroup/cpu/cpu.shares\").is_file():\n+    with open(\"/sys/fs/cgroup/cpu/cpu.shares\", encoding=\"utf-8\") as f:\n+        print(f\"cpu.shares content: {f.read().strip()}\")\n\\ No newline at end of file\ndiff --git a/pylint/lint/run.py b/pylint/lint/run.py\nindex a7e5d557..faa1b925 100644\n--- a/pylint/lint/run.py\n+++ b/pylint/lint/run.py\n@@ -53,11 +53,17 @@ def _query_cpu() -> int | None:\n             cpu_period = int(file.read().rstrip())\n         # Divide quota by period and you should get num of allotted CPU to the container, rounded down if fractional.\n         avail_cpu = int(cpu_quota / cpu_period)\n+        # Ensure at least 1 CPU is returned to avoid multiprocessing errors\n+        if avail_cpu == 0:\n+            avail_cpu = 1\n     elif Path(\"/sys/fs/cgroup/cpu/cpu.shares\").is_file():\n         with open(\"/sys/fs/cgroup/cpu/cpu.shares\", encoding=\"utf-8\") as file:\n             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\n         avail_cpu = int(cpu_shares / 1024)\n+        # Ensure at least 1 CPU is returned to avoid multiprocessing errors\n+        if avail_cpu == 0:\n+            avail_cpu = 1\n     return avail_cpu\n \n \ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 00000000..b9ac04ed\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,92 @@\n+#!/usr/bin/env python3\n+\"\"\"Script to reproduce the issue where _query_cpu() returns 0 in Kubernetes Pod.\"\"\"\n+\n+import os\n+import sys\n+import tempfile\n+from pathlib import Path\n+from unittest.mock import patch, mock_open\n+\n+# Add the pylint directory to the path\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu, _cpu_count\n+\n+def test_query_cpu_returns_zero():\n+    \"\"\"Test that _query_cpu() can return 0 in certain Kubernetes environments.\"\"\"\n+    \n+    # Simulate the Kubernetes environment described in the PR\n+    # /sys/fs/cgroup/cpu/cpu.cfs_quota_us = -1 (not used)\n+    # /sys/fs/cgroup/cpu/cpu.shares = 2\n+    \n+    # Mock the file reads\n+    with patch.object(Path, 'is_file') as mock_is_file:\n+        # Make all files exist\n+        mock_is_file.return_value = True\n+        \n+        # Mock the file contents\n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='-1').return_value,  # cpu.cfs_quota_us\n+            mock_open(read_data='2').return_value,   # cpu.shares\n+        ]):\n+            result = _query_cpu()\n+            print(f\"_query_cpu() returned: {result}\")\n+            # With our fix, it should return 1 instead of 0\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    print(\"\u2713 _query_cpu() correctly returns 1 (not 0) for cpu.shares=2 after fix\")\n+    return result\n+\n+def test_cpu_count_with_zero_query():\n+    \"\"\"Test that _cpu_count() handles _query_cpu() returning 0.\"\"\"\n+    \n+    # Mock _query_cpu to return 0\n+    with patch('pylint.lint.run._query_cpu', return_value=0):\n+        # Mock os.sched_getaffinity to return 4 CPUs\n+        with patch.object(os, 'sched_getaffinity', return_value={0, 1, 2, 3}):\n+            result = _cpu_count()\n+            print(f\"_cpu_count() with _query_cpu()=0 and sched_getaffinity=4: {result}\")\n+            # The min(0, 4) would be 0, which is the problem!\n+            assert result == 0, f\"Expected 0, got {result}\"\n+    \n+    print(\"\u2713 _cpu_count() returns 0 when _query_cpu() returns 0\")\n+    return result\n+\n+def test_actual_issue():\n+    \"\"\"Test the actual issue: when jobs=0 and _cpu_count() returns 0.\"\"\"\n+    \n+    # Create a simple Python file to lint\n+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n+        f.write(\"print('hello')\\n\")\n+        test_file = f.name\n+    \n+    try:\n+        # Import the Run class\n+        from pylint.lint.run import Run\n+        \n+        # Mock _cpu_count to return 0\n+        with patch('pylint.lint.run._cpu_count', return_value=0):\n+            # This should fail with ValueError when trying to create multiprocessing.Pool\n+            try:\n+                # Run pylint with --jobs=0\n+                run = Run([\"--jobs=0\", test_file], exit=False)\n+                print(\"ERROR: Should have raised ValueError!\")\n+                return False\n+            except ValueError as e:\n+                print(f\"\u2713 Got expected ValueError: {e}\")\n+                return True\n+    finally:\n+        # Clean up\n+        os.unlink(test_file)\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing _query_cpu() function...\")\n+    test_query_cpu_returns_zero()\n+    \n+    print(\"\\nTesting _cpu_count() function...\")\n+    test_cpu_count_with_zero_query()\n+    \n+    print(\"\\nTesting actual issue with Run class...\")\n+    test_actual_issue()\n+    \n+    print(\"\\nAll tests completed!\")\n\\ No newline at end of file\ndiff --git a/test_detailed.py b/test_detailed.py\nnew file mode 100644\nindex 00000000..c9fa302f\n--- /dev/null\n+++ b/test_detailed.py\n@@ -0,0 +1,93 @@\n+#!/usr/bin/env python3\n+\"\"\"Detailed test to understand the issue.\"\"\"\n+\n+import os\n+import sys\n+import tempfile\n+from pathlib import Path\n+from unittest.mock import patch, mock_open\n+\n+# Add the pylint directory to the path\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu, _cpu_count\n+\n+def test_edge_cases():\n+    \"\"\"Test various edge cases for _query_cpu().\"\"\"\n+    \n+    test_cases = [\n+        # (cpu_quota, cpu_period, cpu_shares, expected_result)\n+        (-1, 100000, 2, 0),  # Kubernetes case from PR\n+        (-1, 100000, 1024, 1),  # 1024 shares = 1 CPU\n+        (-1, 100000, 2048, 2),  # 2048 shares = 2 CPUs\n+        (-1, 100000, 512, 0),  # 512 shares = 0.5 CPU -> int(0.5) = 0\n+        (100000, 100000, None, 1),  # quota = period = 1 CPU\n+        (50000, 100000, None, 0),  # quota = 0.5 period -> int(0.5) = 0\n+        (200000, 100000, None, 2),  # quota = 2 periods = 2 CPUs\n+        (0, 100000, None, 0),  # quota = 0 -> 0 CPUs\n+    ]\n+    \n+    for i, (quota, period, shares, expected) in enumerate(test_cases):\n+        print(f\"\\nTest case {i+1}: quota={quota}, period={period}, shares={shares}\")\n+        \n+        with patch.object(Path, 'is_file') as mock_is_file:\n+            mock_is_file.return_value = True\n+            \n+            # Prepare file contents\n+            file_contents = []\n+            if quota is not None:\n+                file_contents.append(str(quota))\n+            if period is not None and quota != -1:\n+                file_contents.append(str(period))\n+            if shares is not None and (quota is None or quota == -1):\n+                file_contents.append(str(shares))\n+            \n+            with patch('builtins.open', side_effect=[\n+                mock_open(read_data=content).return_value for content in file_contents\n+            ]):\n+                result = _query_cpu()\n+                print(f\"  Result: {result}, Expected: {expected}\")\n+                assert result == expected, f\"Expected {expected}, got {result}\"\n+    \n+    print(\"\\n\u2713 All edge cases tested\")\n+\n+def test_cpu_count_edge_cases():\n+    \"\"\"Test _cpu_count() with various _query_cpu() results.\"\"\"\n+    \n+    test_cases = [\n+        # (query_cpu_result, sched_getaffinity_result, multiprocessing_cpu_count, expected)\n+        (0, {0, 1, 2, 3}, 4, 0),  # Problem case: min(0, 4) = 0\n+        (1, {0, 1, 2, 3}, 4, 1),  # Normal case\n+        (8, {0, 1, 2, 3}, 4, 4),  # query_cpu > actual CPUs\n+        (None, {0, 1, 2, 3}, 4, 4),  # query_cpu returns None\n+        (0, None, 4, 0),  # No sched_getaffinity, query_cpu=0\n+        (None, None, 4, 4),  # No sched_getaffinity, query_cpu=None\n+        (None, None, 1, 1),  # Single CPU system\n+    ]\n+    \n+    for i, (query_result, sched_result, mp_count, expected) in enumerate(test_cases):\n+        print(f\"\\nTest case {i+1}: query_cpu={query_result}, sched={sched_result}, mp={mp_count}\")\n+        \n+        with patch('pylint.lint.run._query_cpu', return_value=query_result):\n+            with patch.object(os, 'sched_getaffinity', \n+                            return_value=sched_result if sched_result is not None else None):\n+                if sched_result is None:\n+                    # Remove sched_getaffinity attribute\n+                    with patch.object(os, 'sched_getaffinity', None):\n+                        with patch('multiprocessing.cpu_count', return_value=mp_count):\n+                            result = _cpu_count()\n+                else:\n+                    with patch('multiprocessing.cpu_count', return_value=mp_count):\n+                        result = _cpu_count()\n+                \n+                print(f\"  Result: {result}, Expected: {expected}\")\n+                assert result == expected, f\"Expected {expected}, got {result}\"\n+    \n+    print(\"\\n\u2713 All _cpu_count() edge cases tested\")\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing _query_cpu() edge cases...\")\n+    test_edge_cases()\n+    \n+    print(\"\\n\\nTesting _cpu_count() edge cases...\")\n+    test_cpu_count_edge_cases()\n\\ No newline at end of file\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 00000000..6efedaea\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,95 @@\n+#!/usr/bin/env python3\n+\"\"\"Test the fix for _query_cpu returning 0.\"\"\"\n+\n+import os\n+import sys\n+from pathlib import Path\n+from unittest.mock import patch, mock_open\n+\n+# Add the pylint directory to the path\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu, _cpu_count\n+\n+def test_query_cpu_fix():\n+    \"\"\"Test that _query_cpu() never returns 0 after our fix.\"\"\"\n+    \n+    test_cases = [\n+        # (cpu_quota, cpu_period, cpu_shares, expected_result)\n+        (-1, 100000, 2, 1),  # Kubernetes case from PR: 2/1024 = 0 -> should be 1\n+        (-1, 100000, 1024, 1),  # 1024 shares = 1 CPU\n+        (-1, 100000, 2048, 2),  # 2048 shares = 2 CPUs\n+        (-1, 100000, 512, 1),  # 512 shares = 0.5 CPU -> int(0.5) = 0 -> should be 1\n+        (100000, 100000, None, 1),  # quota = period = 1 CPU\n+        (50000, 100000, None, 1),  # quota = 0.5 period -> int(0.5) = 0 -> should be 1\n+        (200000, 100000, None, 2),  # quota = 2 periods = 2 CPUs\n+        (0, 100000, None, None),  # quota = 0 -> falsy, skips to shares check, shares doesn't exist -> None\n+        (-1, 100000, None, None),  # quota = -1, no shares file -> None\n+    ]\n+    \n+    for i, (quota, period, shares, expected) in enumerate(test_cases):\n+        print(f\"\\nTest case {i+1}: quota={quota}, period={period}, shares={shares}\")\n+        \n+        with patch.object(Path, 'is_file') as mock_is_file:\n+            # Make files exist based on test case\n+            def is_file_side_effect(self):\n+                path_str = str(self)\n+                if path_str == \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\":\n+                    return True\n+                elif path_str == \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\":\n+                    return period is not None\n+                elif path_str == \"/sys/fs/cgroup/cpu/cpu.shares\":\n+                    return shares is not None\n+                return False\n+            \n+            mock_is_file.side_effect = is_file_side_effect\n+            \n+            # Prepare file contents\n+            file_contents = []\n+            if quota is not None:\n+                file_contents.append(str(quota))\n+            if period is not None and quota != -1:\n+                file_contents.append(str(period))\n+            if shares is not None and (quota is None or quota == -1):\n+                file_contents.append(str(shares))\n+            \n+            with patch('builtins.open', side_effect=[\n+                mock_open(read_data=content).return_value for content in file_contents\n+            ]):\n+                result = _query_cpu()\n+                print(f\"  Result: {result}, Expected: {expected}\")\n+                if expected is not None:\n+                    assert result == expected, f\"Expected {expected}, got {result}\"\n+                else:\n+                    assert result is None, f\"Expected None, got {result}\"\n+    \n+    print(\"\\n\u2713 All test cases passed\")\n+\n+def test_cpu_count_fix():\n+    \"\"\"Test that _cpu_count() never returns 0 after our fix.\"\"\"\n+    \n+    # Mock _query_cpu to return 1 instead of 0\n+    with patch('pylint.lint.run._query_cpu', return_value=1):\n+        # Mock os.sched_getaffinity to return 4 CPUs\n+        with patch.object(os, 'sched_getaffinity', return_value={0, 1, 2, 3}):\n+            result = _cpu_count()\n+            print(f\"_cpu_count() with _query_cpu()=1 and sched_getaffinity=4: {result}\")\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    # Test with _query_cpu returning None\n+    with patch('pylint.lint.run._query_cpu', return_value=None):\n+        with patch.object(os, 'sched_getaffinity', return_value={0, 1, 2, 3}):\n+            result = _cpu_count()\n+            print(f\"_cpu_count() with _query_cpu()=None and sched_getaffinity=4: {result}\")\n+            assert result == 4, f\"Expected 4, got {result}\"\n+    \n+    print(\"\\n\u2713 _cpu_count() tests passed\")\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing _query_cpu() fix...\")\n+    test_query_cpu_fix()\n+    \n+    print(\"\\n\\nTesting _cpu_count() fix...\")\n+    test_cpu_count_fix()\n+    \n+    print(\"\\nAll tests passed!\")\n\\ No newline at end of file\ndiff --git a/test_manual.py b/test_manual.py\nnew file mode 100644\nindex 00000000..90f9d41c\n--- /dev/null\n+++ b/test_manual.py\n@@ -0,0 +1,36 @@\n+#!/usr/bin/env python3\n+\"\"\"Manual test for _query_cpu.\"\"\"\n+\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu\n+\n+# Let's trace through the logic manually\n+print(\"Testing _query_cpu logic manually...\")\n+\n+# Case 1: cpu_quota = 0\n+print(\"\\nCase 1: cpu_quota = 0\")\n+print(\"Line 48: if cpu_quota and cpu_quota != -1:\")\n+print(\"  cpu_quota = 0, so 'if 0 and 0 != -1:' evaluates to 'if False and True:' = 'if False:'\")\n+print(\"  So it skips to the elif on line 59\")\n+print(\"  Line 59: elif Path('/sys/fs/cgroup/cpu/cpu.shares').is_file():\")\n+print(\"  If cpu.shares file exists, it reads it\")\n+print(\"  If cpu.shares file doesn't exist, avail_cpu remains None\")\n+print(\"  So result should be None if cpu.shares doesn't exist\")\n+\n+# Case 2: cpu_quota = -1\n+print(\"\\nCase 2: cpu_quota = -1\")\n+print(\"Line 48: if cpu_quota and cpu_quota != -1:\")\n+print(\"  cpu_quota = -1, so 'if -1 and -1 != -1:' evaluates to 'if True and False:' = 'if False:'\")\n+print(\"  So it also skips to the elif on line 59\")\n+print(\"  This is the Kubernetes case from the PR\")\n+\n+# Case 3: cpu_quota = 50000\n+print(\"\\nCase 3: cpu_quota = 50000\")\n+print(\"Line 48: if cpu_quota and cpu_quota != -1:\")\n+print(\"  cpu_quota = 50000, so 'if 50000 and 50000 != -1:' evaluates to 'if True and True:' = 'if True:'\")\n+print(\"  So it reads cpu_period and calculates avail_cpu = int(50000 / 100000) = 0\")\n+print(\"  Then our fix sets avail_cpu = 1 if it's 0\")\n+\n+print(\"\\nSo our fix looks correct!\")\n\\ No newline at end of file\ndiff --git a/test_simple.py b/test_simple.py\nnew file mode 100644\nindex 00000000..c94c6e1f\n--- /dev/null\n+++ b/test_simple.py\n@@ -0,0 +1,106 @@\n+#!/usr/bin/env python3\n+\"\"\"Simple test for _query_cpu fix.\"\"\"\n+\n+import os\n+import sys\n+from unittest.mock import patch, mock_open\n+\n+# Add the pylint directory to the path\n+sys.path.insert(0, '/testbed')\n+\n+from pylint.lint.run import _query_cpu\n+\n+def test_query_cpu():\n+    \"\"\"Test _query_cpu with various inputs.\"\"\"\n+    \n+    # Test 1: cpu.shares = 2 (Kubernetes case from PR)\n+    print(\"Test 1: cpu.shares = 2\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        # Mock Path class\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='-1').return_value,  # cpu.cfs_quota_us\n+            mock_open(read_data='2').return_value,   # cpu.shares\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: 1\")\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    # Test 2: cpu.shares = 512 (0.5 CPU)\n+    print(\"\\nTest 2: cpu.shares = 512\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='-1').return_value,  # cpu.cfs_quota_us\n+            mock_open(read_data='512').return_value,  # cpu.shares\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: 1\")\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    # Test 3: cpu_quota = 50000, cpu_period = 100000 (0.5 CPU)\n+    print(\"\\nTest 3: cpu_quota = 50000, cpu_period = 100000\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='50000').return_value,   # cpu.cfs_quota_us\n+            mock_open(read_data='100000').return_value,  # cpu.cfs_period_us\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: 1\")\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    # Test 4: cpu_quota = 0, cpu_period = 100000 (0 CPU)\n+    print(\"\\nTest 4: cpu_quota = 0, cpu_period = 100000\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='0').return_value,      # cpu.cfs_quota_us\n+            mock_open(read_data='100000').return_value, # cpu.cfs_period_us\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: None (0 is falsy, skips to shares)\")\n+            # cpu_quota is 0, which is falsy, so it skips to cpu.shares check\n+            # but cpu.shares file doesn't exist in this mock, so returns None\n+            assert result is None, f\"Expected None, got {result}\"\n+    \n+    # Test 5: cpu_quota = 100000, cpu_period = 100000 (1 CPU)\n+    print(\"\\nTest 5: cpu_quota = 100000, cpu_period = 100000\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='100000').return_value,  # cpu.cfs_quota_us\n+            mock_open(read_data='100000').return_value,   # cpu.cfs_period_us\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: 1\")\n+            assert result == 1, f\"Expected 1, got {result}\"\n+    \n+    # Test 6: cpu_quota = 200000, cpu_period = 100000 (2 CPUs)\n+    print(\"\\nTest 6: cpu_quota = 200000, cpu_period = 100000\")\n+    with patch('pylint.lint.run.Path') as MockPath:\n+        mock_path_instance = MockPath.return_value\n+        mock_path_instance.is_file.return_value = True\n+        \n+        with patch('builtins.open', side_effect=[\n+            mock_open(read_data='200000').return_value,  # cpu.cfs_quota_us\n+            mock_open(read_data='100000').return_value,  # cpu.cfs_period_us\n+        ]):\n+            result = _query_cpu()\n+            print(f\"  Result: {result}, Expected: 2\")\n+            assert result == 2, f\"Expected 2, got {result}\"\n+    \n+    print(\"\\n\u2713 All tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_query_cpu()\n\\ No newline at end of file\n"}