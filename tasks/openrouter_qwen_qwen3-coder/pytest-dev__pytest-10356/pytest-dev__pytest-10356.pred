{"model_name_or_path": "openrouter_qwen_qwen3-coder", "instance_id": "pytest-dev__pytest-10356", "model_patch": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..fae5fef78 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -357,10 +357,26 @@ class MarkDecorator:\n \n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n-    return normalize_mark_list(mark_list)\n+    # If obj is a class, consider marks from all classes in the MRO\n+    if isinstance(obj, type):\n+        marks = []\n+        seen_mark_names = set()\n+        for cls in obj.__mro__:\n+            mark_list = getattr(cls, \"pytestmark\", [])\n+            if not isinstance(mark_list, list):\n+                mark_list = [mark_list]\n+            # Add marks, but avoid duplicates by name (MRO order)\n+            for mark in mark_list:\n+                if mark.name not in seen_mark_names:\n+                    marks.append(mark)\n+                    seen_mark_names.add(mark.name)\n+        return normalize_mark_list(marks)\n+    else:\n+        # For non-class objects, use the original behavior\n+        mark_list = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(mark_list, list):\n+            mark_list = [mark_list]\n+        return normalize_mark_list(mark_list)\n \n \n def normalize_mark_list(\ndiff --git a/testing/test_multiple_inheritance_marks.py b/testing/test_multiple_inheritance_marks.py\nnew file mode 100644\nindex 000000000..e8a84e084\n--- /dev/null\n+++ b/testing/test_multiple_inheritance_marks.py\n@@ -0,0 +1,55 @@\n+import pytest\n+\n+def test_multiple_inheritance_marks() -> None:\n+    \"\"\"Test that marks from multiple base classes are correctly merged.\"\"\"\n+    # Create a simple test to check our fix\n+    import sys\n+    from _pytest.mark.structures import get_unpacked_marks\n+    \n+    # Define classes with marks\n+    @pytest.mark.foo\n+    class Foo(object):\n+        pass\n+\n+    @pytest.mark.bar\n+    class Bar(object):\n+        pass\n+\n+    class TestDings(Foo, Bar):\n+        def test_dings(self):\n+            pass\n+    \n+    # Check that both marks are present\n+    marks = list(get_unpacked_marks(TestDings))\n+    mark_names = [mark.name for mark in marks]\n+    \n+    assert \"foo\" in mark_names\n+    assert \"bar\" in mark_names\n+    assert len(marks) == 2\n+\n+def test_multiple_inheritance_marks_with_same_name() -> None:\n+    \"\"\"Test that marks with the same name from different base classes are handled correctly.\"\"\"\n+    # Create a simple test to check our fix\n+    import sys\n+    from _pytest.mark.structures import get_unpacked_marks\n+    \n+    # Define classes with marks\n+    @pytest.mark.skip(param=\"base1\")\n+    class Base1(object):\n+        pass\n+\n+    @pytest.mark.skip(param=\"base2\")\n+    class Base2(object):\n+        pass\n+\n+    class TestDings(Base1, Base2):\n+        def test_dings(self):\n+            pass\n+    \n+    # Check that only one marker is present (from the first base class in MRO)\n+    marks = list(get_unpacked_marks(TestDings))\n+    mark_names = [mark.name for mark in marks]\n+    \n+    assert \"skip\" in mark_names\n+    assert len(marks) == 1\n+    assert marks[0].kwargs == {\"param\": \"base1\"}\n\\ No newline at end of file\n"}