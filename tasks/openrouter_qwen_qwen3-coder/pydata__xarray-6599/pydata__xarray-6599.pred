{"model_name_or_path": "openrouter_qwen_qwen3-coder", "instance_id": "pydata__xarray-6599", "model_patch": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 823cbe02..cb8aba70 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1892,6 +1892,7 @@ def polyval(\n     xarray.DataArray.polyfit\n     numpy.polynomial.polynomial.polyval\n     \"\"\"\n+    from .dataarray import DataArray\n \n     if degree_dim not in coeffs._indexes:\n         raise ValueError(\n@@ -1905,20 +1906,47 @@ def polyval(\n     coeffs = coeffs.reindex(\n         {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False\n     )\n-    coord = _ensure_numeric(coord)  # type: ignore # https://github.com/python/mypy/issues/1533 ?\n+    \n+    # Extract coordinate values for evaluation while preserving original coordinates\n+    original_coords = None\n+    if isinstance(coord, DataArray):\n+        # For DataArray, use the coordinate values, not the data values\n+        if len(coord.dims) == 1:\n+            dim_name = coord.dims[0]\n+            if dim_name in coord.coords:\n+                # Store original coordinates to preserve them in the result\n+                original_coords = {dim_name: coord.coords[dim_name]}\n+                # Use the coordinate values for this dimension for computation\n+                coord_values = coord.coords[dim_name]\n+                # Apply numeric conversion to coordinate values for computation\n+                coord_for_computation = _ensure_numeric(coord_values)\n+            else:\n+                # Fallback to using the data values\n+                coord_for_computation = _ensure_numeric(coord)\n+        else:\n+            # For multi-dimensional DataArrays, use the data values\n+            coord_for_computation = _ensure_numeric(coord)\n+    else:\n+        # For Dataset or already processed coordinates, apply numeric conversion\n+        coord_for_computation = _ensure_numeric(coord)\n+        coord = coord_for_computation\n \n     # using Horner's method\n     # https://en.wikipedia.org/wiki/Horner%27s_method\n-    res = coeffs.isel({degree_dim: max_deg}, drop=True) + zeros_like(coord)\n+    res = coeffs.isel({degree_dim: max_deg}, drop=True) + zeros_like(coord_for_computation)\n     for deg in range(max_deg - 1, -1, -1):\n-        res *= coord\n+        res *= coord_for_computation\n         res += coeffs.isel({degree_dim: deg}, drop=True)\n \n+    # Restore original coordinates if we modified them\n+    if original_coords is not None and isinstance(res, DataArray):\n+        res = res.assign_coords(original_coords)\n+\n     return res\n \n \n def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n-    \"\"\"Converts all datetime64 variables to float64\n+    \"\"\"Converts all datetime64 and timedelta64 variables to float64\n \n     Parameters\n     ----------\n@@ -1928,12 +1956,13 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n     Returns\n     -------\n     DataArray or Dataset\n-        Variables with datetime64 dtypes converted to float64.\n+        Variables with datetime64/timedelta64 dtypes converted to float64.\n     \"\"\"\n     from .dataset import Dataset\n+    from .dataarray import DataArray\n \n     def to_floatable(x: DataArray) -> DataArray:\n-        if x.dtype.kind in \"mM\":\n+        if x.dtype.kind == \"M\":  # datetime64\n             return x.copy(\n                 data=datetime_to_numeric(\n                     x.data,\n@@ -1941,10 +1970,27 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n                     datetime_unit=\"ns\",\n                 ),\n             )\n+        elif x.dtype.kind == \"m\":  # timedelta64\n+            # For timedelta64, convert directly to numeric without offset\n+            data = x.data\n+            if data.dtype != np.dtype('timedelta64[ns]'):\n+                # Convert to nanoseconds if needed\n+                data = data / np.timedelta64(1, 'ns')\n+            return x.copy(data=data.astype(float))\n         return x\n \n     if isinstance(data, Dataset):\n         return data.map(to_floatable)\n+    elif isinstance(data, DataArray):\n+        # Process the data variable\n+        result = to_floatable(data)\n+        # Also process the coordinates\n+        new_coords = {}\n+        for name, coord in result.coords.items():\n+            new_coords[name] = to_floatable(coord)\n+        if new_coords:\n+            result = result.assign_coords(new_coords)\n+        return result\n     else:\n         return to_floatable(data)\n \n"}