{"model_name_or_path": "openrouter_qwen_qwen3-coder", "instance_id": "pydata__xarray-6721", "model_patch": "diff --git a/xarray/core/common.py b/xarray/core/common.py\nindex 3c328f42..c1283b70 100644\n--- a/xarray/core/common.py\n+++ b/xarray/core/common.py\n@@ -2023,8 +2023,10 @@ def get_chunksizes(\n \n     chunks: dict[Any, tuple[int, ...]] = {}\n     for v in variables:\n-        if hasattr(v.data, \"chunks\"):\n-            for dim, c in v.chunksizes.items():\n+        # Use the chunksizes property which handles different data types correctly\n+        var_chunks = v.chunksizes\n+        if var_chunks:  # Only process if there are chunks\n+            for dim, c in var_chunks.items():\n                 if dim in chunks and c != chunks[dim]:\n                     raise ValueError(\n                         f\"Object has inconsistent chunks along dimension {dim}. \"\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 2d115ff0..ceaf1aea 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1014,6 +1014,21 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):\n         Variable.chunks\n         xarray.unify_chunks\n         \"\"\"\n+        # Check if we have encoding with chunks information (e.g., for zarr arrays)\n+        if \"chunks\" in self.encoding and self.encoding[\"chunks\"] is not None:\n+            chunks = self.encoding[\"chunks\"]\n+            # Handle different types of chunks in encoding:\n+            # 1. Integer: same chunk size for all dimensions\n+            # 2. Tuple: explicit chunk sizes for each dimension\n+            if isinstance(chunks, int):\n+                # Same chunk size for all dimensions\n+                return Frozen({dim: chunks for dim in self.dims})\n+            elif isinstance(chunks, (tuple, list)):\n+                # Explicit chunk sizes for each dimension\n+                return Frozen({dim: c for dim, c in zip(self.dims, chunks)})\n+            else:\n+                # Unexpected type, fall back to default behavior\n+                pass\n         if hasattr(self._data, \"chunks\"):\n             return Frozen({dim: c for dim, c in zip(self.dims, self.data.chunks)})\n         else:\n"}