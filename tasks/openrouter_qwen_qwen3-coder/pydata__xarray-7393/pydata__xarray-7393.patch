diff --git a/xarray/core/common.py b/xarray/core/common.py
index 3c328f42..c1283b70 100644
--- a/xarray/core/common.py
+++ b/xarray/core/common.py
@@ -2023,8 +2023,10 @@ def get_chunksizes(
 
     chunks: dict[Any, tuple[int, ...]] = {}
     for v in variables:
-        if hasattr(v.data, "chunks"):
-            for dim, c in v.chunksizes.items():
+        # Use the chunksizes property which handles different data types correctly
+        var_chunks = v.chunksizes
+        if var_chunks:  # Only process if there are chunks
+            for dim, c in var_chunks.items():
                 if dim in chunks and c != chunks[dim]:
                     raise ValueError(
                         f"Object has inconsistent chunks along dimension {dim}. "
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 2d115ff0..ceaf1aea 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -1014,6 +1014,21 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):
         Variable.chunks
         xarray.unify_chunks
         """
+        # Check if we have encoding with chunks information (e.g., for zarr arrays)
+        if "chunks" in self.encoding and self.encoding["chunks"] is not None:
+            chunks = self.encoding["chunks"]
+            # Handle different types of chunks in encoding:
+            # 1. Integer: same chunk size for all dimensions
+            # 2. Tuple: explicit chunk sizes for each dimension
+            if isinstance(chunks, int):
+                # Same chunk size for all dimensions
+                return Frozen({dim: chunks for dim in self.dims})
+            elif isinstance(chunks, (tuple, list)):
+                # Explicit chunk sizes for each dimension
+                return Frozen({dim: c for dim, c in zip(self.dims, chunks)})
+            else:
+                # Unexpected type, fall back to default behavior
+                pass
         if hasattr(self._data, "chunks"):
             return Frozen({dim: c for dim, c in zip(self.dims, self.data.chunks)})
         else:
