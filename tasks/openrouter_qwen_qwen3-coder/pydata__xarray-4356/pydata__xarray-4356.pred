{"model_name_or_path": "openrouter_qwen_qwen3-coder", "instance_id": "pydata__xarray-4356", "model_patch": "diff --git a/xarray/core/nanops.py b/xarray/core/nanops.py\nindex 41c8d258..c6c6b817 100644\n--- a/xarray/core/nanops.py\n+++ b/xarray/core/nanops.py\n@@ -26,21 +26,42 @@ def _maybe_null_out(result, axis, mask, min_count=1):\n     \"\"\"\n     xarray version of pandas.core.nanops._maybe_null_out\n     \"\"\"\n-    if hasattr(axis, \"__len__\"):  # if tuple or list\n-        raise ValueError(\n-            \"min_count is not available for reduction with more than one dimensions.\"\n-        )\n-\n     if axis is not None and getattr(result, \"ndim\", False):\n-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0\n+        # Handle both single axis and multiple axes\n+        if hasattr(axis, \"__len__\"):  # if tuple or list\n+            # For multiple axes, calculate the product of the dimensions being reduced\n+            reduced_size = np.prod(np.take(mask.shape, axis))\n+            valid_count = reduced_size - mask.sum(axis=axis)\n+            null_mask = (valid_count - min_count) < 0\n+        else:\n+            # For single axis, use the original logic\n+            valid_count = mask.shape[axis] - mask.sum(axis)\n+            null_mask = (valid_count - min_count) < 0\n+        \n         if null_mask.any():\n             dtype, fill_value = dtypes.maybe_promote(result.dtype)\n             result = result.astype(dtype)\n             result[null_mask] = fill_value\n \n+    elif axis is not None:  # For scalar results (0-dimensional)\n+        # Handle both single axis and multiple axes for scalar results\n+        if hasattr(axis, \"__len__\"):  # if tuple or list\n+            # For multiple axes, calculate the product of the dimensions being reduced\n+            reduced_size = np.prod(np.take(mask.shape, axis))\n+            valid_count = reduced_size - mask.sum(axis=axis)\n+            null_mask = (valid_count - min_count) < 0\n+        else:\n+            # For single axis, use the original logic\n+            valid_count = mask.shape[axis] - mask.sum(axis)\n+            null_mask = (valid_count - min_count) < 0\n+        \n+        if null_mask:\n+            result = np.nan\n+\n     elif getattr(result, \"dtype\", None) not in dtypes.NAT_TYPES:\n-        null_mask = mask.size - mask.sum()\n-        if null_mask < min_count:\n+        valid_count = mask.size - mask.sum()\n+        null_mask = (valid_count - min_count) < 0\n+        if null_mask:\n             result = np.nan\n \n     return result\n"}